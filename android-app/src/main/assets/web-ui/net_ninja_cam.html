<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>NET_NiNjA :: CAM VIEWER</title>

<!-- Attached theme CSS (verbatim) -->
<style>
/* Created by: Justin Linwood Ross */
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

:root{
  --bg1:#050012;
  --neon-pink:#ff00ff;
  --neon-blue:#00f0ff;
  --glass-bg: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
}

*{box-sizing:border-box}
html,body{height:100%; margin:0; font-family:'Orbitron',sans-serif; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;}
body{
  background: radial-gradient(circle at 30% 20%, #120023 0%, #04000a 60%, #000 100%);
  color:#e8e6ff;
  overflow:hidden;
  position:relative;
}

#bg { position:fixed; inset:0; z-index:0; display:block; }

.glass-panel{
  position:absolute; z-index:2;
  width:440px; padding:22px; border-radius:16px;
  background: var(--glass-bg);
  border: 1px solid rgba(255,255,255,0.06);
  box-shadow:
    0 8px 40px rgba(0,0,0,0.6),
    0 0 35px rgba(255,0,255,0.08),
    0 0 80px rgba(0,240,255,0.06);
  backdrop-filter: blur(10px) saturate(140%);
  color:#fff;
  overflow:visible;
}

#translator-panel{ left:6%; top:50%; transform:translateY(-50%); width:520px; }
#country-panel{ right:6%; top:12%; width:360px; max-height:76vh; overflow:auto; }

.visually-hidden{ position:absolute; left:-9999px; top:auto; width:1px; height:1px; overflow:hidden; }

.neon-title{
  font-size:2.6rem; color:var(--neon-pink); margin:4px 0 6px;
  text-shadow: 0 0 10px var(--neon-pink), 0 0 40px var(--neon-blue), 0 0 90px var(--neon-pink);
  letter-spacing:2px;
  animation: neonFlicker 2.5s infinite alternate;
}
@keyframes neonFlicker {
  0%,100%{ text-shadow:0 0 10px #ff00ff,0 0 40px #00f0ff,0 0 90px #ff00ff; }
  25%{ text-shadow:0 0 15px #ff00ff,0 0 50px #00f0ff,0 0 100px #ff00ff; }
  50%{ text-shadow:0 0 12px #ff00ff,0 0 45px #00f0ff,0 0 95px #ff00ff; }
  75%{ text-shadow:0 0 18px #ff00ff,0 0 55px #00f0ff,0 0 105px #ff00ff; }
}

.subtitle{ color:#bcb7df; margin:0 0 12px; font-size:0.95rem; }

.controls{ display:flex; flex-direction:column; gap:12px; }
.helper-text{
  font-size:12px;
  color:#9fd4ff;
  opacity:0.9;
}
.helper-text strong{ color: var(--neon-blue); }
textarea{
  width:100%; min-height:110px; resize:vertical; border-radius:10px; padding:12px; font-size:14px;
  background: rgba(0,0,0,0.5); border:1px solid rgba(255,255,255,0.04); color:#fff; outline:none;
  box-shadow: inset 0 0 10px rgba(0,0,0,0.6);
}
.controls-row{ display:flex; gap:12px; align-items:center; }
.controls-row.secondary{ justify-content:space-between; }
.quick-actions{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
.select-wrap{ flex:1; }
.actions{ display:flex; gap:8px; align-items:center; }

select, button{
  padding:10px 12px; border-radius:10px; border:1px solid rgba(255,255,255,0.06);
  background: rgba(0,0,0,0.45); color:#fff; font-weight:700;
}
button{
  background: linear-gradient(90deg,var(--neon-pink),var(--neon-blue));
  background-size:200% 200%;
  color:#000; cursor:pointer;
  box-shadow: 0 10px 30px rgba(0,0,0,0.6), 0 0 18px rgba(255,0,255,0.06);
  animation: buttonGlow 4s ease infinite;
}
button:hover{ transform:translateY(-2px); box-shadow: 0 18px 40px rgba(0,0,0,0.6), 0 0 30px rgba(255,0,255,0.12); }
@keyframes buttonGlow {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

.output-glass{ margin-top:12px; background: rgba(0,0,0,0.35); border-radius:10px; padding:10px; border:1px solid rgba(255,255,255,0.03); color:#dfefff; line-height:1.45; 
box-shadow: 0 0 8px #00f0ff, 0 0 24px #ff00ff, 0 0 48px #00f0ff;
animation: panelPulse 3s infinite alternate;}
@keyframes panelPulse {
  0%{box-shadow:0 0 8px #00f0ff,0 0 24px #ff00ff,0 0 48px #00f0ff;}
  50%{box-shadow:0 0 12px #00f0ff,0 0 30px #ff00ff,0 0 60px #00f0ff;}
  100%{box-shadow:0 0 8px #00f0ff,0 0 24px #ff00ff,0 0 48px #00f0ff;}
}
.output-glass h2{ margin:0 0 8px; color:var(--neon-blue); font-size:1rem; }
.output-text{ color:#dfefff; font-size:0.98rem; min-height:36px; }

#country-meta{ font-size:0.95rem; color:#d9eaff; }
#country-meta strong{ color:var(--neon-pink); font-size:1.05rem; }
#country-desc-text{ margin-top:8px; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:12px; border-radius:8px; border:1px solid rgba(255,255,255,0.03); color:#bfefff; line-height:1.45; }

#country-panel::-webkit-scrollbar{ width:8px; }
#country-panel::-webkit-scrollbar-thumb{ background: linear-gradient(45deg,var(--neon-pink),var(--neon-blue)); border-radius:8px; }

.ripple { position: absolute; left: 50%; transform: translateX(-50%); border-radius:50%; border: 2px solid rgba(0,240,255,0.12); pointer-events:none; animation:ripple 2s ease-out forwards; top: 6px; filter: blur(1.8px);}
.ripple.small { width:80px; height:80px; }
.ripple.medium { width:120px; height:120px; }
.ripple.large { width:160px; height:160px; }
@keyframes ripple { to { transform: translateX(-50%) scale(6); opacity:0; } }

.arc { position: fixed; width:6px; height:6px; border-radius:50%; background: var(--neon-blue); box-shadow: 0 0 24px var(--neon-blue); pointer-events:none; animation: arcfade 280ms ease-out forwards; }
@keyframes arcfade { to { transform: scale(2); opacity:0; } }

.flicker { animation: flicker 200ms linear 0s 3; }
@keyframes flicker { 0%{opacity:1} 50%{opacity:0.85; transform:translateY(-2px);} 100%{opacity:1} }

@media (max-width:1100px) {
  #translator-panel{ left:4%; width:86vw; }
  #country-panel{ display:none; }
}
</style>

<!-- Added: cyber button skin (required because only markup was provided) -->
<style>

/* NET_NiNjA cyber button skin (since only markup was provided).
   Keeps the glitch span from rendering as plain text when styles are missing. */
.cybr-btn{
  --btn-bg: rgba(0,0,0,0.55);
  --btn-border: rgba(255,255,255,0.10);
  --btn-text: #e8e6ff;
  --btn-glow1: var(--neon-blue);
  --btn-glow2: var(--neon-pink);

  position: relative;
  display: inline-flex;
  align-items: center;
  justify-content: center;

  padding: 12px 16px;
  min-height: 44px;

  border-radius: 12px;
  border: 1px solid var(--btn-border);
  background: linear-gradient(90deg, rgba(255,0,255,0.22), rgba(0,240,255,0.18)) , var(--btn-bg);
  color: var(--btn-text);
  font-family: inherit;
  font-weight: 900;
  letter-spacing: 0.5px;

  cursor: pointer;
  user-select: none;

  box-shadow:
    0 10px 26px rgba(0,0,0,0.55),
    0 0 18px rgba(0,240,255,0.16),
    0 0 18px rgba(255,0,255,0.14);
  backdrop-filter: blur(10px) saturate(140%);
}
.cybr-btn:active{ transform: translateY(1px); }
.cybr-btn:hover{
  box-shadow:
    0 16px 34px rgba(0,0,0,0.62),
    0 0 26px rgba(0,240,255,0.22),
    0 0 26px rgba(255,0,255,0.18);
}

/* The glitch span exists in your markup; keep it hidden unless you want it. */
.cybr-btn__glitch{
  position: absolute;
  inset: 0;
  display: none; /* Prevent duplicate text */
  align-items: center;
  justify-content: center;
  opacity: 0.0;
  pointer-events: none;
}

/* Optional: quick “glitch flicker” on hover without duplicating text */
.cybr-btn:hover .cybr-btn__glitch{
  display:flex;
  opacity: 0.12;
  filter: blur(0.4px);
  text-shadow: 0 0 10px var(--btn-glow1), 0 0 14px var(--btn-glow2);
  animation: cybrFlicker 420ms steps(2,end) 1;
}
@keyframes cybrFlicker{
  0%{ transform: translate(0,0); opacity: 0.0; }
  25%{ transform: translate(1px,-1px); opacity: 0.12; }
  55%{ transform: translate(-1px,1px); opacity: 0.08; }
  100%{ transform: translate(0,0); opacity: 0.10; }
}

</style>

<!-- Added: camera dashboard layout -->
<style>

/* ===== Camera dashboard layout layer ===== */
#cam-grid-panel{
  position:absolute; z-index:3;
  left:50%; top:52%;
  transform:translate(-50%, -50%);
  width:min(1100px, 92vw);
  height:min(78vh, 720px);
  padding:16px; border-radius:16px;
  background: var(--glass-bg);
  border: 1px solid rgba(255,255,255,0.06);
  box-shadow: 0 8px 40px rgba(0,0,0,0.6),
              0 0 35px rgba(255,0,255,0.08),
              0 0 80px rgba(0,240,255,0.06);
  backdrop-filter: blur(10px) saturate(140%);
  overflow:hidden;
  display:flex;
  flex-direction:column;
  gap:12px;
}

.grid-toolbar{ display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; }
.grid-toolbar .left, .grid-toolbar .right{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; }

.pill{
  display:inline-flex; align-items:center; gap:8px;
  padding:8px 10px; border-radius:999px;
  background: rgba(0,0,0,0.45);
  border:1px solid rgba(255,255,255,0.06);
  color:#fff; font-weight:800; font-size:12px;
  white-space:nowrap;
}
.dot{ width:8px; height:8px; border-radius:50%;
  background: var(--neon-blue);
  box-shadow: 0 0 18px rgba(0,240,255,0.55);
}
.dot.warn{ background: var(--neon-pink); box-shadow: 0 0 18px rgba(255,0,255,0.55); }

#cam-grid{
  flex:1;
  display:grid;
  gap:12px;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  overflow:auto;
  padding-right:6px;
}
#cam-grid.grid-1{ grid-template-columns: 1fr; }
#cam-grid.grid-4{ grid-template-columns: repeat(2, minmax(0, 1fr)); }
#cam-grid.grid-9{ grid-template-columns: repeat(3, minmax(0, 1fr)); }
#cam-grid.grid-wall{ grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); }

.tile{
  position:relative;
  border-radius:14px;
  overflow:hidden;
  background: rgba(0,0,0,0.55);
  border:1px solid rgba(255,255,255,0.06);
  box-shadow: inset 0 0 14px rgba(0,0,0,0.7),
              0 0 24px rgba(0,240,255,0.06),
              0 0 24px rgba(255,0,255,0.06);
  min-height:190px;
}
.tile video, .tile img{
  width:100%; height:100%;
  object-fit:cover;
  display:block;
  background: rgba(0,0,0,0.35);
}
.cam-placeholder{
  width:100%;
  height:100%;
  display:flex;
  align-items:center;
  justify-content:center;
  text-align:center;
  padding:20px;
  font-size:13px;
  line-height:1.4;
  color:#ffb6e6;
  background: radial-gradient(circle at 30% 20%, rgba(255,0,255,0.16), rgba(0,0,0,0.75));
}
.tile.has-error{
  border-color: rgba(255, 0, 128, 0.35);
  box-shadow: inset 0 0 14px rgba(0,0,0,0.7),
              0 0 24px rgba(255,0,128,0.18),
              0 0 24px rgba(0,240,255,0.04);
}

.hud{
  position:absolute; inset:0;
  display:flex; flex-direction:column;
  justify-content:space-between;
  pointer-events:none;
}
.hud-top{
  padding:10px;
  display:flex; align-items:center; justify-content:space-between; gap:10px;
  background: linear-gradient(180deg, rgba(0,0,0,0.75), rgba(0,0,0,0));
}
.hud-name{
  font-weight:900; font-size:13px;
  color: var(--neon-blue);
  text-shadow: 0 0 10px rgba(0,240,255,0.35), 0 0 24px rgba(255,0,255,0.20);
  white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
  max-width:70%;
}
.hud-tag{
  font-size:11px; font-weight:900; color:#000;
  background: linear-gradient(90deg,var(--neon-pink),var(--neon-blue));
  padding:6px 10px; border-radius:999px;
  box-shadow: 0 0 18px rgba(255,0,255,0.10);
  white-space:nowrap;
}
.hud-bottom{
  padding:10px;
  display:flex; align-items:flex-end; justify-content:space-between; gap:10px;
  background: linear-gradient(0deg, rgba(0,0,0,0.80), rgba(0,0,0,0));
}
.hud-url{
  font-size:12px; color:#bfefff; line-height:1.2;
  max-width:65%;
  overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
}
.hud-status{
  font-size:11px; color:#9fd4ff; line-height:1.2;
  max-width:65%;
  overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
}
.hud-actions{
  pointer-events:auto;
  display:flex; gap:10px; align-items:center; flex-wrap:wrap;
}
.hud-actions .cybr-btn{
  min-height: 34px;
  padding: 8px 10px;
  font-size: 11px;
}
.list-hint{
  font-size:12px;
  color:#bfefff;
  margin-bottom:8px;
}
.cam-list{
  display:flex;
  flex-direction:column;
  gap:10px;
  max-height:48vh;
  overflow:auto;
  padding-right:6px;
}

/* If any imported button CSS tries to center body, force normal page flow */
body{
  display:block !important;
  justify-content: unset !important;
  align-items: unset !important;
  flex-direction: unset !important;
  font-size: unset !important;
  min-height: 100vh !important;
}

/* ===== Mobile: stop absolute overlays and stack panels ===== */
@media (max-width: 780px){
  body{
    overflow:auto !important;
  }
  #translator-panel, #country-panel, #cam-grid-panel{
    position: relative !important;
    left: auto !important;
    right: auto !important;
    top: auto !important;
    transform: none !important;
    width: 92vw !important;
    margin: 14px auto !important;
  }
  #cam-grid-panel{
    height: 64vh !important;
  }
  #country-panel{
    max-height: none !important;
    overflow: visible !important;
  }
}

</style>
</head>

<body>
<canvas id="bg"></canvas>

<div class="nn-overlay" id="nnOverlay"></div>

<nav class="nn-side" id="nnSide">
  <div class="panel-title">NET_NiNjA MENU</div>

  <div class="menu">
    <button class="cybr-btn" type="button" data-nav="overview">
      Overview <span class="hint">grid focus</span>
      <span aria-hidden class="cybr-btn__glitch">Overview</span>
    </button>

    <button class="cybr-btn" type="button" data-nav="cameras">
      Cameras <span class="hint">list + grid</span>
      <span aria-hidden class="cybr-btn__glitch">Cameras</span>
    </button>

    <button class="cybr-btn" type="button" data-nav="configure">
      Configure <span class="hint">urls + modes</span>
      <span aria-hidden class="cybr-btn__glitch">Configure</span>
    </button>

    <button class="cybr-btn" type="button" data-open="addCam">
      Add camera <span class="hint">name + url</span>
      <span aria-hidden class="cybr-btn__glitch">Add camera</span>
    </button>

    <button class="cybr-btn" type="button" data-open="import">
      Import list <span class="hint">paste urls</span>
      <span aria-hidden class="cybr-btn__glitch">Import list</span>
    </button>

    <button class="cybr-btn" type="button" data-act="export">
      Export list <span class="hint">copy</span>
      <span aria-hidden class="cybr-btn__glitch">Export list</span>
    </button>

    <button class="cybr-btn" type="button" data-open="gateway">
      RTSP gateway <span class="hint">MediaMTX</span>
      <span aria-hidden class="cybr-btn__glitch">RTSP gateway</span>
    </button>

    <button class="cybr-btn" type="button" data-open="settings">
      Settings <span class="hint">layout</span>
      <span aria-hidden class="cybr-btn__glitch">Settings</span>
    </button>
  </div>
</nav>

<header class="nn-topbar">
  <div class="left">
    <button class="nn-hamburger" id="nnHamburger" type="button" aria-label="Open menu">
      <div class="bars">
        <div class="bar"></div>
        <div class="bar"></div>
        <div class="bar"></div>
      </div>
    </button>

    <div class="nn-brand">NET_NiNjA :: CAMS</div>

    <div class="nn-chip" title="Quick status">
      <span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:var(--neon-blue);box-shadow:0 0 16px rgba(0,240,255,.55)"></span>
      <span id="nnQuickStatus">READY</span>
    </div>
  </div>

  <div class="right">
    <button class="cybr-btn" type="button" id="nnBtnAdd">
      Add
      <span aria-hidden class="cybr-btn__glitch">Add</span>
    </button>

    <button class="cybr-btn" type="button" id="nnBtnReconnect">
      Reconnect
      <span aria-hidden class="cybr-btn__glitch">Reconnect</span>
    </button>

    <button class="cybr-btn" type="button" id="nnBtnView">
      View
      <span aria-hidden class="cybr-btn__glitch">View</span>
    </button>
  </div>
</header>

<!-- ===== Modals ===== -->
<div class="nn-modal" id="modalAddCam" aria-hidden="true">
  <section class="glass-panel">
    <div class="neon-title" style="font-size:1.6rem">ADD CAMERA</div>
    <p class="subtitle">Give it a name and a stream URL (HLS/MJPEG/HTTP). RTSP needs gateway.</p>

    <div class="controls">
      <div class="row">
        <div style="flex:1;min-width:220px">
          <label class="visually-hidden" for="addCamName">Name</label>
          <input id="addCamName" placeholder="Camera name (e.g. Front Door)"/>
        </div>
        <div style="flex:2;min-width:240px">
          <label class="visually-hidden" for="addCamUrl">URL</label>
          <input id="addCamUrl" placeholder="https://...m3u8 OR http://...mjpeg"/>
        </div>
      </div>

      <div class="row" style="justify-content:flex-end;">
        <button class="cybr-btn" type="button" data-close="addCam">Cancel<span aria-hidden class="cybr-btn__glitch">Cancel</span></button>
        <button class="cybr-btn" type="button" id="btnAddCamConfirm">Add<span aria-hidden class="cybr-btn__glitch">Add</span></button>
      </div>
    </div>
  </section>
</div>

<div class="nn-modal" id="modalImport" aria-hidden="true">
  <section class="glass-panel">
    <div class="neon-title" style="font-size:1.6rem">IMPORT CAMERA LIST</div>
    <p class="subtitle">Paste URLs (one per line). Optional: “Name | URL”.</p>

    <div class="controls">
      <textarea id="importText" placeholder="Front Door | https://...m3u8&#10;Garage | http://...mjpeg&#10;https://...m3u8"></textarea>

      <div class="row" style="justify-content:flex-end;">
        <button class="cybr-btn" type="button" data-close="import">Cancel<span aria-hidden class="cybr-btn__glitch">Cancel</span></button>
        <button class="cybr-btn" type="button" id="btnImportConfirm">Import<span aria-hidden class="cybr-btn__glitch">Import</span></button>
      </div>
    </div>
  </section>
</div>

<div class="nn-modal" id="modalGateway" aria-hidden="true">
  <section class="glass-panel">
    <div class="neon-title" style="font-size:1.6rem">RTSP GATEWAY</div>
    <p class="subtitle">Browsers do not play RTSP. Use MediaMTX (or similar) to convert RTSP → HLS/WebRTC.</p>
    <div class="output-glass">
      <h2>What to do</h2>
      <div class="output-text">
        1) Run MediaMTX on your LAN.<br/>
        2) Add RTSP inputs.<br/>
        3) Use the generated HLS (.m3u8) or WebRTC URL in this dashboard.
      </div>
    </div>
    <div class="row" style="justify-content:flex-end;margin-top:12px;">
      <button class="cybr-btn" type="button" data-close="gateway">Close<span aria-hidden class="cybr-btn__glitch">Close</span></button>
    </div>
  </section>
</div>

<div class="nn-modal" id="modalSettings" aria-hidden="true">
  <section class="glass-panel">
    <div class="neon-title" style="font-size:1.6rem">SETTINGS</div>
    <p class="subtitle">UI controls that don’t pretend to be magic.</p>

    <div class="controls">
      <div class="row">
        <div style="flex:1;min-width:220px">
          <div class="subtitle" style="margin-bottom:6px;">Panels</div>
          <select id="settingPanels">
            <option value="all" selected>Show input + list + grid</option>
            <option value="grid">Grid only</option>
            <option value="config">Input + grid</option>
            <option value="list">List + grid</option>
          </select>
        </div>
        <div style="flex:1;min-width:220px">
          <div class="subtitle" style="margin-bottom:6px;">Default view</div>
          <select id="settingDefaultView">
            <option value="cameras" selected>Cameras</option>
            <option value="overview">Overview</option>
            <option value="configure">Configure</option>
          </select>
        </div>
      </div>

      <div class="row" style="justify-content:flex-end;">
        <button class="cybr-btn" type="button" data-close="settings">Close<span aria-hidden class="cybr-btn__glitch">Close</span></button>
        <button class="cybr-btn" type="button" id="btnSettingsApply">Apply<span aria-hidden class="cybr-btn__glitch">Apply</span></button>
      </div>
    </div>
  </section>
</div>

<div class="nn-main-offset"></div>

<section id="translator-panel" class="glass-panel">
  <div id="titleText" class="neon-title">NET_NiNjA CAM VIEWER</div>
  <p class="subtitle">HLS / HTTP / MJPEG in-browser. RTSP needs gateway (MediaMTX → HLS/WebRTC).</p>

  <div class="controls">
    <label class="visually-hidden" for="inputText">Camera URLs</label>
    <textarea id="inputText" placeholder="Paste camera URLs (one per line).&#10;Use Name | URL to label feeds.&#10;Example:&#10;Lobby | https://.../stream.m3u8&#10;http://.../video.mjpeg"></textarea>
    <div class="helper-text" id="inputHelp">
      Tips: use <strong>Name | URL</strong>, lines starting with <strong>#</strong> are ignored, RTSP needs a gateway.
    </div>

    <div class="controls-row">
      <div class="select-wrap">
        <select id="gridMode">
          <option value="grid-4" selected>2x2 grid</option>
          <option value="grid-1">1-up</option>
          <option value="grid-9">3x3</option>
          <option value="grid-wall">Wall</option>
        </select>
      </div>
      <div class="select-wrap">
        <select id="muteMode">
          <option value="all" selected>Mute all</option>
          <option value="focused">Only focused</option>
          <option value="none">Unmute all</option>
        </select>
      </div>
      <div class="actions">
        <button class="cybr-btn" type="button" id="translateBtn">
          Load grid
          <span aria-hidden class="cybr-btn__glitch">Load grid</span>
        </button>
        <button class="cybr-btn" type="button" id="btnReconnectAll">
          Reconnect all
          <span aria-hidden class="cybr-btn__glitch">Reconnect all</span>
        </button>
        <button class="cybr-btn" type="button" id="btnDiscover">
          Discover (ONVIF)
          <span aria-hidden class="cybr-btn__glitch">Discover (ONVIF)</span>
        </button>
      </div>
    </div>

    <div class="controls-row secondary">
      <div class="select-wrap">
        <select id="autoReconnect">
          <option value="0" selected>Auto reconnect: Off</option>
          <option value="30000">Auto reconnect: 30s</option>
          <option value="60000">Auto reconnect: 60s</option>
          <option value="120000">Auto reconnect: 120s</option>
        </select>
      </div>
      <div class="quick-actions">
        <button class="cybr-btn" type="button" id="btnPasteClipboard">
          Paste
          <span aria-hidden class="cybr-btn__glitch">Paste</span>
        </button>
        <button class="cybr-btn" type="button" id="btnClearList">
          Clear
          <span aria-hidden class="cybr-btn__glitch">Clear</span>
        </button>
        <button class="cybr-btn" type="button" id="btnDownloadList">
          Download
          <span aria-hidden class="cybr-btn__glitch">Download</span>
        </button>
      </div>
    </div>

    <div class="output-glass">
      <h2>STATUS</h2>
      <div class="output-text" id="outputText">Ready.</div>
    </div>
  </div>
</section>

<!-- Camera grid panel -->
<section id="cam-grid-panel">
  <div class="grid-toolbar">
    <div class="left">
      <div class="pill"><span class="dot" id="runDot"></span><span id="runState">IDLE</span></div>
      <div class="pill">Cameras: <span id="camCount">0</span></div>
      <div class="pill">Live: <span id="liveCount">0</span></div>
    </div>
    <div class="right">
      <div class="pill">Mode: <span id="gridModeLabel">GRID</span></div>
    </div>
  </div>
  <div id="cam-grid" class="grid-4"></div>
</section>

<!-- Country info panel -->
<section id="country-panel" class="glass-panel">
  <div class="neon-title" style="font-size:1.8rem">COUNTRY INFO</div>
  <div id="country-meta">
    <div><strong id="countryName">---</strong></div>
    <div id="countryDetails">Region: -- | Capital: --</div>
  </div>
  <div id="country-desc-text">
    <div class="list-hint">Camera list (tap to focus). Translation info will appear below.</div>
    <div id="camList" class="cam-list"></div>
  </div>
</section>

<!-- Theme scripts -->
<script src="script.js"></script>

<script>
// Disable default translator response during camera usage.
// (We overwrite listeners later.)
document.addEventListener('DOMContentLoaded', () => {
  const translateBtn = document.getElementById('translateBtn');
  if(translateBtn){
    translateBtn.onclick = null;
  }
});
</script>

<!-- Camera dashboard logic -->
<script>
(function detachAttachedTranslateHandler(){
  // script.js attaches listeners to #translateBtn. We replace the node to remove those listeners.
  const oldBtn = document.getElementById('translateBtn');
  if(!oldBtn) return;
  const clone = oldBtn.cloneNode(true);
  oldBtn.parentNode.replaceChild(clone, oldBtn);
})();

const state = {
  cams: [],
  focused: null,
  muteMode: 'all',
  gridMode: 'grid-4',
  autoReconnectMs: 0,
  autoReconnectTimer: null
};
const STORAGE_KEY = 'net_ninja_cam_state_v2';
const CAM_TIMEOUT_MS = 12000;
const elGrid = document.getElementById('cam-grid');
const elList = document.getElementById('camList');
const elStatus = document.getElementById('outputText');
const elRunState = document.getElementById('runState');
const elRunDot = document.getElementById('runDot');
const elCamCount = document.getElementById('camCount');
const elLiveCount = document.getElementById('liveCount');
const elAutoReconnect = document.getElementById('autoReconnect');
const supports = { hls: supportsHls() };

function setStatus(msg, warn=false){
  elStatus.textContent = msg;
  elRunState.textContent = warn ? 'WARN' : (state.cams.length ? 'RUN' : 'IDLE');
  elRunDot.className = warn ? 'dot warn' : 'dot';
}

function normalizeUrl(raw){
  if(!raw) return '';
  const trimmed = raw.trim();
  if(!trimmed) return '';
  if(/^[a-z][a-z0-9+.-]*:\/\//i.test(trimmed)) return trimmed;
  if(trimmed.startsWith('//')) return `http:${trimmed}`;
  if(/^[\w.-]+(:\d+)?(\/|$)/.test(trimmed)) return `http://${trimmed}`;
  return trimmed;
}

function splitNameAndUrl(line){
  if(!line) return { name: '', url: '' };
  const parts = line.split('|');
  if(parts.length >= 2){
    const name = parts[0].trim();
    const url = parts.slice(1).join('|').trim();
    return { name, url };
  }
  return { name: '', url: line.trim() };
}

function guessType(url){
  const lower = url.toLowerCase();
  if(lower.startsWith('rtsp://')) return 'RTSP';
  if(lower.includes('.m3u8')) return 'HLS';
  if(lower.includes('mjpeg') || lower.endsWith('.mjpg') || lower.endsWith('.mjpeg')) return 'MJPEG';
  if(lower.endsWith('.mp4') || lower.endsWith('.webm') || lower.endsWith('.ogg')) return 'VIDEO';
  if(lower.endsWith('.ts') || lower.endsWith('.mpegts')) return 'MPEGTS';
  return 'HTTP';
}

function guessName(url, index){
  try{
    const u = new URL(url);
    const host = u.hostname ? u.hostname.replace(/^www\./,'') : '';
    if(host) return `${host}:${u.port || ''}`.replace(/:$/, '');
  }catch{
    // ignore
  }
  return `Cam ${index + 1}`;
}

function parseLinesToCams(text){
  const lines = (text || '')
    .split(/\r?\n/)
    .map(s => s.trim())
    .filter(line => line && !line.startsWith('#') && !line.startsWith('//'));

  const cams = [];
  lines.forEach((line) => {
    const { name, url } = splitNameAndUrl(line);
    const normalized = normalizeUrl(url);
    if(!normalized) return;
    const type = guessType(normalized);
    const displayName = name || guessName(normalized, cams.length);
    cams.push({
      id: (crypto && crypto.randomUUID) ? crypto.randomUUID() : ('cam-' + Date.now() + '-' + cams.length),
      name: displayName,
      url: normalized,
      type,
      playing: false,
      err: null,
      statusText: 'Queued',
      warn: false,
      timeoutId: null
    });
  });
  return cams;
}

function setGridClass(cls){
  elGrid.classList.remove('grid-1','grid-4','grid-9','grid-wall');
  elGrid.classList.add(cls);
  state.gridMode = cls;
}

function requestFullscreen(el){
  const req = el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen;
  if(req) req.call(el);
}

function reconnectTile(tile){
  const media = tile.querySelector('video, img');
  if(!media) return;
  const src = media.dataset.src || media.src;
  media.src = '';
  setTimeout(() => {
    if(media.tagName.toLowerCase() === 'img'){
      const bust = src.includes('?') ? `${src}&nn=${Date.now()}` : `${src}?nn=${Date.now()}`;
      media.src = bust;
    } else {
      media.src = src;
    }
    if(media.tagName.toLowerCase() === 'video'){
      media.load();
      media.play().catch(() => {});
    }
  }, 350);
}

function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[c]));
}

function supportsHls(){
  const v = document.createElement('video');
  if(!v.canPlayType) return false;
  return Boolean(v.canPlayType('application/vnd.apple.mpegurl') || v.canPlayType('application/x-mpegURL'));
}

function updateCamStatus(cam, text, isError=false){
  cam.statusText = text;
  cam.err = isError ? text : null;
  if(cam._statusEl){
    cam._statusEl.textContent = text;
    cam._statusEl.style.color = isError ? '#ff7b7b' : '#bfefff';
  }
  if(cam._listStatusEl){
    cam._listStatusEl.textContent = text;
    cam._listStatusEl.style.color = isError ? '#ff7b7b' : '#9fd4ff';
  }
  if(cam._tileEl){
    cam._tileEl.classList.toggle('has-error', isError);
  }
}

function applyMuteMode(){
  const mode = state.muteMode;
  document.querySelectorAll('#cam-grid video').forEach(v => {
    if(mode === 'all') v.muted = true;
    else if(mode === 'none') v.muted = false;
    else {
      const tile = v.closest('.tile');
      const id = tile && tile.__camId;
      v.muted = (id !== state.focused);
    }
  });
}

function reconnectAll(){
  document.querySelectorAll('#cam-grid .tile').forEach(t => reconnectTile(t));
}

function setAutoReconnect(ms){
  if(state.autoReconnectTimer){
    clearInterval(state.autoReconnectTimer);
    state.autoReconnectTimer = null;
  }
  state.autoReconnectMs = ms;
  if(ms > 0){
    state.autoReconnectTimer = setInterval(() => {
      if(!state.cams.length) return;
      reconnectAll();
      setStatus(`Auto reconnect ran (${Math.round(ms / 1000)}s).`);
    }, ms);
  }
}

async function pasteFromClipboard(){
  try{
    const text = await navigator.clipboard.readText();
    if(!text){
      setStatus('Clipboard is empty.', true);
      return;
    }
    const ta = document.getElementById('inputText');
    if(ta){
      ta.value = (ta.value ? ta.value.trimEnd() + '\n' : '') + text.trim();
    }
    setStatus('Clipboard pasted. Press Load grid.', false);
  }catch{
    setStatus('Clipboard access blocked. Paste manually.', true);
  }
}

function downloadList(){
  const ta = document.getElementById('inputText');
  const content = (ta?.value || '').trim();
  if(!content){
    setStatus('Nothing to download.', true);
    return;
  }
  const blob = new Blob([content], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'net_ninja_cam_list.txt';
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
  setStatus('List downloaded.');
}

function updateLive(){
  const live = state.cams.filter(c => c.playing).length;
  elLiveCount.textContent = String(live);
}

function persistState(){
  try{
    const ta = document.getElementById('inputText');
    const payload = {
      list: ta?.value || '',
      gridMode: state.gridMode,
      muteMode: state.muteMode,
      autoReconnectMs: state.autoReconnectMs
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
  }catch{
    // ignore storage failures
  }
}

function restoreState(){
  try{
    const ta = document.getElementById('inputText');
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return;
    const saved = JSON.parse(raw);
    if(ta && !ta.value.trim() && saved.list){
      ta.value = saved.list;
    }
    if(saved.gridMode){
      state.gridMode = saved.gridMode;
      const sel = document.getElementById('gridMode');
      if(sel) sel.value = saved.gridMode;
    }
    if(saved.muteMode){
      state.muteMode = saved.muteMode;
      const sel = document.getElementById('muteMode');
      if(sel) sel.value = saved.muteMode;
    }
    if(typeof saved.autoReconnectMs === 'number'){
      state.autoReconnectMs = saved.autoReconnectMs;
      if(elAutoReconnect) elAutoReconnect.value = String(saved.autoReconnectMs);
    }
  }catch{
    // ignore parse errors
  }
}

function render(){
  elGrid.innerHTML = '';
  if(elList) elList.innerHTML = '';
  elCamCount.textContent = String(state.cams.length);

  let live = 0;

  state.cams.forEach((cam) => {
    const item = document.createElement('div');
    item.style.marginBottom = '10px';
    item.style.padding = '10px';
    item.style.borderRadius = '10px';
    item.style.border = '1px solid rgba(255,255,255,0.06)';
    item.style.background = 'rgba(0,0,0,0.35)';
    item.style.cursor = 'pointer';
    const statusEl = document.createElement('div');
    statusEl.style.marginTop = '6px';
    statusEl.style.fontSize = '12px';
    statusEl.style.color = '#9fd4ff';

    item.innerHTML =
      '<div style="font-weight:900;color:var(--neon-blue);text-shadow:0 0 10px rgba(0,240,255,0.25)">' + escapeHtml(cam.name) + '</div>' +
      '<div style="font-size:12px;color:#bfefff;opacity:.85;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">' + escapeHtml(cam.url) + '</div>' +
      '<div style="margin-top:6px;font-size:12px;"><span class="hud-tag">' + escapeHtml(cam.type) + '</span></div>';
    item.appendChild(statusEl);
    item.onclick = () => { state.focused = cam.id; render(); };
    if(elList) elList.appendChild(item);

    const tile = document.createElement('div');
    tile.className = 'tile';
    tile.__camId = cam.id;
    if(state.focused === cam.id) tile.style.outline = '2px solid rgba(0,240,255,0.28)';

    let media;
    cam._tileEl = tile;
    cam._statusEl = null;
    cam._listStatusEl = statusEl;
    cam.warn = false;

    if(cam.type === 'RTSP'){
      media = document.createElement('div');
      media.className = 'cam-placeholder';
      media.textContent = 'RTSP requires a gateway (MediaMTX → HLS/WebRTC).';
      updateCamStatus(cam, 'RTSP needs gateway', true);
      cam.warn = true;
    } else if(cam.type === 'MJPEG'){
      media = document.createElement('img');
      media.dataset.src = cam.url;
      media.src = cam.url;
      updateCamStatus(cam, 'Connecting…');
      cam.timeoutId = setTimeout(() => {
        if(!cam.playing){
          updateCamStatus(cam, 'No signal (timeout)', true);
          updateLive();
        }
      }, CAM_TIMEOUT_MS);
      media.onload = () => {
        cam.playing = true;
        clearTimeout(cam.timeoutId);
        updateCamStatus(cam, 'Live');
        updateLive();
      };
      media.onerror = () => {
        cam.playing = false;
        clearTimeout(cam.timeoutId);
        updateCamStatus(cam, 'MJPEG error', true);
        updateLive();
      };
    } else {
      if(cam.type === 'HLS' && !supports.hls){
        media = document.createElement('div');
        media.className = 'cam-placeholder';
        media.textContent = 'HLS not supported in this browser. Use Safari or a gateway.';
        updateCamStatus(cam, 'HLS unsupported', true);
        cam.warn = true;
      } else {
        media = document.createElement('video');
        media.dataset.src = cam.url;
        media.src = cam.url;
        media.autoplay = true;
        media.muted = true;
        media.playsInline = true;
        media.preload = 'metadata';
        updateCamStatus(cam, 'Connecting…');
        cam.timeoutId = setTimeout(() => {
          if(!cam.playing){
            updateCamStatus(cam, 'No signal (timeout)', true);
            updateLive();
          }
        }, CAM_TIMEOUT_MS);
        media.onplaying = () => {
          cam.playing = true;
          clearTimeout(cam.timeoutId);
          updateCamStatus(cam, 'Live');
          updateLive();
        };
        media.onwaiting = () => {
          if(!cam.playing) return;
          updateCamStatus(cam, 'Buffering…');
        };
        media.onerror = () => {
          cam.playing = false;
          clearTimeout(cam.timeoutId);
          if(cam.type === 'HTTP' && !cam._fallbackAttempted){
            cam._fallbackAttempted = true;
            media.remove();
            cam.type = 'MJPEG';
            const img = document.createElement('img');
            img.dataset.src = cam.url;
            img.src = cam.url;
            img.onload = () => {
              cam.playing = true;
              updateCamStatus(cam, 'Live (MJPEG)');
              updateLive();
            };
            img.onerror = () => {
              cam.playing = false;
              updateCamStatus(cam, 'Stream error', true);
              updateLive();
            };
            tile.insertBefore(img, tile.firstChild);
            updateCamStatus(cam, 'Switching to MJPEG…');
            return;
          }
          updateCamStatus(cam, 'Stream error', true);
          updateLive();
        };
        media.onstalled = () => {
          cam.playing = false;
          updateCamStatus(cam, 'Stalled', true);
          updateLive();
        };
        media.play().catch(() => {
          cam.playing = false;
          updateCamStatus(cam, 'Autoplay blocked', true);
          updateLive();
        });
      }
    }

    const hud = document.createElement('div');
    hud.className = 'hud';
    const hudTop = document.createElement('div');
    hudTop.className = 'hud-top';
    const hudName = document.createElement('div');
    hudName.className = 'hud-name';
    hudName.textContent = cam.name;
    const hudTag = document.createElement('div');
    hudTag.className = 'hud-tag';
    hudTag.textContent = cam.type;
    hudTop.appendChild(hudName);
    hudTop.appendChild(hudTag);

    const hudBottom = document.createElement('div');
    hudBottom.className = 'hud-bottom';
    const hudUrl = document.createElement('div');
    hudUrl.className = 'hud-url';
    hudUrl.textContent = cam.url;
    const hudStatus = document.createElement('div');
    hudStatus.className = 'hud-status';
    hudStatus.textContent = cam.statusText || 'Queued';
    const hudActions = document.createElement('div');
    hudActions.className = 'hud-actions';
    hudActions.innerHTML =
      '<button class="cybr-btn" data-act="reconnect" type="button">Reconnect<span aria-hidden class="cybr-btn__glitch">Reconnect</span></button>' +
      '<button class="cybr-btn" data-act="full" type="button">Fullscreen<span aria-hidden class="cybr-btn__glitch">Fullscreen</span></button>';

    hudBottom.appendChild(hudUrl);
    hudBottom.appendChild(hudStatus);
    hudBottom.appendChild(hudActions);
    hud.appendChild(hudTop);
    hud.appendChild(hudBottom);

    tile.appendChild(media);
    tile.appendChild(hud);
    cam._statusEl = hudStatus;
    cam._listStatusEl = statusEl;
    updateCamStatus(cam, cam.statusText || 'Connecting…', Boolean(cam.err));

    tile.querySelector('[data-act="reconnect"]').onclick = (e) => { e.stopPropagation(); reconnectTile(tile); };
    tile.querySelector('[data-act="full"]').onclick = (e) => { e.stopPropagation(); requestFullscreen(tile); };
    tile.onclick = () => { state.focused = cam.id; render(); };

    elGrid.appendChild(tile);
    if(cam.playing) live++;
  });

  elLiveCount.textContent = String(live);
  applyMuteMode();

  const warn = state.cams.some(cam => cam.warn);
  if(elList && !state.cams.length){
    const empty = document.createElement('div');
    empty.className = 'list-hint';
    empty.textContent = 'No cameras loaded yet. Add URLs or import a list.';
    elList.appendChild(empty);
  }

  if(!state.cams.length) setStatus('Ready. Paste URLs and press Load grid.');
  else setStatus('Loaded ' + state.cams.length + ' camera(s). Tap a tile to focus.', warn);
}

function closeAllOverlays(){
  document.querySelectorAll('.nn-modal').forEach(m=>{
    m.classList.remove('open');
    m.setAttribute('aria-hidden','true');
  });
  document.getElementById('nnSide')?.classList.remove('open');
  document.getElementById('nnOverlay')?.classList.remove('open');
}

// Wire controls
document.getElementById('inputText').addEventListener('change', () => {
  persistState();
});

document.getElementById('translateBtn').addEventListener('click', () => {
  const txt = document.getElementById('inputText').value;
  state.cams = parseLinesToCams(txt);
  state.focused = state.cams[0]?.id || null;
  if(!state.cams.length){
    setStatus('No valid camera URLs found. Add URLs or use Name | URL.', true);
    render();
    return;
  }
  render();
  persistState();
});

document.getElementById('gridMode').addEventListener('change', (e) => {
  const mode = e.target.value;
  setGridClass(mode);
  const label = document.getElementById('gridModeLabel');
  if(label) label.textContent = mode.replace('grid-','').toUpperCase();
  persistState();
});

document.getElementById('muteMode').addEventListener('change', (e) => {
  state.muteMode = e.target.value;
  applyMuteMode();
  persistState();
});

document.getElementById('btnReconnectAll').addEventListener('click', () => {
  reconnectAll();
  setStatus('Reconnect all triggered.');
});

document.getElementById('btnDiscover').addEventListener('click', () => {
  setStatus('ONVIF discovery is a hook. Feed discovered stream URLs into the list.', true);
});

elAutoReconnect?.addEventListener('change', (e) => {
  const ms = Number(e.target.value);
  setAutoReconnect(Number.isFinite(ms) ? ms : 0);
  persistState();
  setStatus(ms ? `Auto reconnect enabled (${Math.round(ms / 1000)}s).` : 'Auto reconnect disabled.');
});

document.getElementById('btnPasteClipboard').addEventListener('click', () => {
  pasteFromClipboard();
});

document.getElementById('btnClearList').addEventListener('click', () => {
  const ok = confirm('Clear the current camera list?');
  if(!ok) return;
  const ta = document.getElementById('inputText');
  if(ta) ta.value = '';
  state.cams = [];
  state.focused = null;
  render();
  persistState();
  setStatus('Camera list cleared.');
});

document.getElementById('btnDownloadList').addEventListener('click', () => {
  downloadList();
});

document.addEventListener('keydown', (e) => {
  if((e.ctrlKey || e.metaKey) && e.key === 'Enter'){
    e.preventDefault();
    document.getElementById('translateBtn')?.click();
  }
  if(e.key === 'Escape'){
    closeAllOverlays();
  }
});

restoreState();
setGridClass(state.gridMode);
const gridLabel = document.getElementById('gridModeLabel');
if(gridLabel) gridLabel.textContent = state.gridMode.replace('grid-','').toUpperCase();
if(elAutoReconnect) elAutoReconnect.value = String(state.autoReconnectMs || 0);
setAutoReconnect(state.autoReconnectMs || 0);
setStatus('Ready. Paste URLs and press Load grid.');
render();

// ===== Public API so the nav/menu can control the dashboard =====
window.NetNinjaCam = {
  addCamera: ({name, url}) => {
    const ta = document.getElementById('inputText');
    const normalized = normalizeUrl(url || '');
    if(!normalized) return;
    const line = (name && name.trim() ? (name.trim() + ' | ' + normalized) : normalized);
    // Also keep the raw list in the textarea for user visibility.
    if(ta){
      ta.value = (ta.value ? (ta.value.trimEnd() + '\n') : '') + line;
    }
    // Load to grid (re-uses existing handler)
    document.getElementById('translateBtn')?.click();
  },
  importList: (text) => {
    // Accept "Name | URL" or just URL.
    const lines = String(text || '').split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    const ta = document.getElementById('inputText');
    if(ta){
      ta.value = lines.join('\n');
    }
    document.getElementById('translateBtn')?.click();
  },
  exportList: () => {
    const ta = document.getElementById('inputText');
    return (ta?.value || '').trim();
  },
  reconnectAll: () => {
    document.getElementById('btnReconnectAll')?.click();
  },
  setGridMode: (mode) => {
    const sel = document.getElementById('gridMode');
    if(sel){
      sel.value = mode;
      sel.dispatchEvent(new Event('change'));
    }
  }
};

</script>

<script>
(function(){
  const side = document.getElementById('nnSide');
  const overlay = document.getElementById('nnOverlay');
  const ham = document.getElementById('nnHamburger');

  const modalAdd = document.getElementById('modalAddCam');
  const modalImport = document.getElementById('modalImport');
  const modalGateway = document.getElementById('modalGateway');
  const modalSettings = document.getElementById('modalSettings');

  const quick = document.getElementById('nnQuickStatus');

  function openSide(){
    side.classList.add('open');
    overlay.classList.add('open');
  }
  function closeSide(){
    side.classList.remove('open');
    overlay.classList.remove('open');
  }

  function openModal(which){
    const map = {
      addCam: modalAdd,
      import: modalImport,
      gateway: modalGateway,
      settings: modalSettings
    };
    const m = map[which];
    if(!m) return;
    m.classList.add('open');
    m.setAttribute('aria-hidden','false');
    overlay.classList.add('open');
  }
  function closeAllModals(){
    [modalAdd, modalImport, modalGateway, modalSettings].forEach(m=>{
      m.classList.remove('open');
      m.setAttribute('aria-hidden','true');
    });
    overlay.classList.remove('open');
  }

  ham?.addEventListener('click', ()=> {
    if(side.classList.contains('open')) closeSide(); else openSide();
  });
  overlay?.addEventListener('click', ()=> {
    closeSide();
    closeAllModals();
  });

  // Side menu buttons
  side?.addEventListener('click', (e)=>{
    const btn = e.target.closest('button');
    if(!btn) return;

    const nav = btn.getAttribute('data-nav');
    const open = btn.getAttribute('data-open');
    const act = btn.getAttribute('data-act');

    if(nav){
      setView(nav);
      closeSide();
      return;
    }
    if(open){
      closeSide();
      openModal(open);
      return;
    }
    if(act === 'export'){
      doExport();
      closeSide();
      return;
    }
  });

  document.querySelectorAll('[data-close]').forEach(b=>{
    b.addEventListener('click', ()=>{
      closeAllModals();
    });
  });

  // Topbar quick buttons
  document.getElementById('nnBtnAdd')?.addEventListener('click', ()=> openModal('addCam'));
  document.getElementById('nnBtnReconnect')?.addEventListener('click', ()=> {
    window.NetNinjaCam?.reconnectAll?.();
    pulseQuick('RECONNECT');
  });
  document.getElementById('nnBtnView')?.addEventListener('click', ()=> {
    setView('overview');
    pulseQuick('VIEW');
  });

  function pulseQuick(txt){
    if(!quick) return;
    quick.textContent = txt;
    quick.classList.add('flicker');
    setTimeout(()=> quick.classList.remove('flicker'), 420);
    setTimeout(()=> quick.textContent = 'READY', 900);
  }

  function setPanels(mode){
    const t = document.getElementById('translator-panel');
    const c = document.getElementById('country-panel');
    // grid always visible
    const show = (el, v)=>{ if(!el) return; el.style.display = v ? '' : 'none'; };

    if(mode === 'grid'){ show(t,false); show(c,false); }
    else if(mode === 'config'){ show(t,true); show(c,false); }
    else if(mode === 'list'){ show(t,false); show(c,true); }
    else { show(t,true); show(c,true); }
  }

  function setView(view){
    // Views are just combinations of panel visibility + mild behavior changes.
    // This is UI, not magic.
    if(view === 'overview'){
      setPanels('grid');
      window.scrollTo({top:0, behavior:'smooth'});
    } else if(view === 'configure'){
      setPanels('config');
      window.scrollTo({top:0, behavior:'smooth'});
    } else {
      // cameras
      setPanels('all');
      window.scrollTo({top:0, behavior:'smooth'});
    }
  }

  // Add camera modal
  document.getElementById('btnAddCamConfirm')?.addEventListener('click', ()=>{
    const name = (document.getElementById('addCamName')?.value || '').trim();
    const url  = (document.getElementById('addCamUrl')?.value || '').trim();
    if(!url){
      pulseQuick('NEED URL');
      return;
    }
    window.NetNinjaCam?.addCamera?.({name, url});
    closeAllModals();
    pulseQuick('ADDED');
  });

  // Import modal
  document.getElementById('btnImportConfirm')?.addEventListener('click', ()=>{
    const txt = (document.getElementById('importText')?.value || '').trim();
    if(!txt){
      pulseQuick('EMPTY');
      return;
    }
    window.NetNinjaCam?.importList?.(txt);
    closeAllModals();
    pulseQuick('IMPORTED');
  });

  // Settings modal
  document.getElementById('btnSettingsApply')?.addEventListener('click', ()=>{
    const p = document.getElementById('settingPanels')?.value || 'all';
    const v = document.getElementById('settingDefaultView')?.value || 'cameras';
    setPanels(p);
    setView(v);
    closeAllModals();
    pulseQuick('APPLIED');
  });

  function doExport(){
    const txt = window.NetNinjaCam?.exportList?.() || '';
    if(!txt){
      pulseQuick('NONE');
      return;
    }
    try{
      navigator.clipboard.writeText(txt);
      pulseQuick('COPIED');
    }catch{
      // fallback: dump into inputText
      const ta = document.getElementById('inputText');
      if(ta){ ta.value = txt; }
      pulseQuick('EXPORT');
    }
  }

  // Default offset so panels don't hide behind topbar (desktop too).
  document.body.classList.add('nn-main-offset');

  // Apply default view
  setView('cameras');
})();
</script>

</body>
</html>
