*** Begin Patch
*** Add File: android-app/src/main/java/com/netninja/openclaw/OpenClawGatewayService.kt
package com.netninja.openclaw

import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.Service
import android.content.Intent
import android.os.IBinder
import androidx.core.app.NotificationCompat
import java.util.concurrent.ConcurrentHashMap

/**
 * Foreground service that hosts the OpenClaw gateway. This service starts
 * a WebSocket server on the specified port and maintains a registry of
 * connected nodes. Each node must send a HELLO message on connect to
 * register itself. The gateway responds with a REGISTERED message and
 * updates last seen timestamps for heartbeat messages. This class is
 * designed to be longâ€‘running and resilient; it stops only when the
 * service is destroyed by the system or the user.
 */
class OpenClawGatewayService : Service() {
    companion object {
        const val CHANNEL_ID = "openclaw_gateway"
        const val NOTIF_ID = 9001
        const val PORT = 18789
    }

    private lateinit var socketServer: OpenClawWebSocketServer
    private val nodes = ConcurrentHashMap<String, OpenClawNode>()

    override fun onCreate() {
        super.onCreate()
        createNotificationChannel()
        socketServer = OpenClawWebSocketServer(PORT) { msg, session ->
            handleMessage(msg, session)
        }
        socketServer.start()
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        startForeground(NOTIF_ID, buildNotification())
        return START_STICKY
    }

    override fun onDestroy() {
        socketServer.stop()
        super.onDestroy()
    }

    override fun onBind(intent: Intent?): IBinder? = null

    private fun handleMessage(msg: OpenClawMessage, session: NodeSession) {
        when (msg.type) {
            "HELLO" -> {
                val node = OpenClawNode(
                    id = msg.nodeId,
                    capabilities = msg.capabilities,
                    session = session
                )
                nodes[msg.nodeId] = node
                session.send(OpenClawMessage.registered(msg.nodeId))
            }
            "HEARTBEAT" -> {
                nodes[msg.nodeId]?.lastSeen = System.currentTimeMillis()
            }
            "RESULT" -> {
                nodes[msg.nodeId]?.lastResult = msg.payload
            }
        }
    }

    private fun buildNotification(): Notification =
        NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle("OpenClaw Gateway")
            .setContentText("Gateway active on port $PORT")
            .setSmallIcon(android.R.drawable.stat_sys_upload)
            .setOngoing(true)
            .build()

    private fun createNotificationChannel() {
        val channel = NotificationChannel(
            CHANNEL_ID,
            "OpenClaw Gateway",
            NotificationManager.IMPORTANCE_LOW
        )
        val mgr = getSystemService(NotificationManager::class.java)
        mgr?.createNotificationChannel(channel)
    }
}
