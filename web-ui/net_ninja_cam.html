<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>NET_NiNjA :: CAM GRID</title>
<style>
  :root{
    --bg:#05060a;
    --panel:#0b0f1a;
    --panel2:#070a12;
    --line:rgba(176,0,255,.35);
    --cyan:#00ffff;
    --purple:#b000ff;
    --mint:#3affa3;
    --pink:#ff2fa4;
    --text:#cfeaff;
    --muted:rgba(207,234,255,.65);

    --r:18px;
    --shadow: 0 0 0 1px rgba(176,0,255,.25), 0 16px 60px rgba(0,0,0,.6);
    --glowC: 0 0 12px rgba(0,255,255,.35), 0 0 36px rgba(176,0,255,.20);
    --glowP: 0 0 14px rgba(176,0,255,.35), 0 0 44px rgba(255,47,164,.12);
    --glowM: 0 0 12px rgba(58,255,163,.25);
  }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    background:
      radial-gradient(1000px 500px at 20% -10%, rgba(0,255,255,.10), transparent 60%),
      radial-gradient(900px 480px at 90% 0%, rgba(176,0,255,.10), transparent 65%),
      radial-gradient(900px 500px at 50% 120%, rgba(255,47,164,.08), transparent 65%),
      linear-gradient(180deg, #05060a, #03040a 65%, #05060a);
    color:var(--text);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    overflow-x:hidden;
    overflow-y:auto;
    -webkit-overflow-scrolling: touch;
  }

  /* subtle scanlines + grain */
  body:before{
    content:"";
    position:fixed; inset:0;
    background:
      repeating-linear-gradient(to bottom,
        rgba(255,255,255,.02) 0px,
        rgba(255,255,255,.02) 1px,
        rgba(0,0,0,0) 3px,
        rgba(0,0,0,0) 6px);
    mix-blend-mode:soft-light;
    pointer-events:none;
    opacity:.35;
  }
  body:after{
    content:"";
    position:fixed; inset:0;
    background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='220' height='220'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='220' height='220' filter='url(%23n)' opacity='.12'/%3E%3C/svg%3E");
    opacity:.30;
    pointer-events:none;
    mix-blend-mode:overlay;
  }

  /* layout */
  .app{
    min-height:100dvh;
    display:grid;
    grid-template-rows: 64px 1fr;
    grid-template-columns: 1fr;
  }

  /* top bar */
  .topbar{
    display:flex;
    align-items:center;
    gap:14px;
    padding:12px 14px;
    border-bottom:1px solid rgba(176,0,255,.22);
    background: linear-gradient(180deg, rgba(10,14,24,.9), rgba(7,10,18,.55));
    backdrop-filter: blur(10px);
    flex-wrap: wrap;
  }

  .brand{
    display:flex;
    align-items:center;
    gap:10px;
    min-width: 220px;
    flex: 1 1 auto;
  }
  .logo{
    width:34px; height:34px; border-radius: 12px;
    background:
      radial-gradient(circle at 35% 30%, rgba(0,255,255,.35), transparent 55%),
      radial-gradient(circle at 70% 65%, rgba(176,0,255,.35), transparent 60%),
      linear-gradient(135deg, rgba(255,47,164,.18), rgba(0,0,0,.2));
    box-shadow: var(--glowP);
    border:1px solid rgba(176,0,255,.35);
    position:relative;
    overflow:hidden;
  }
  .logo:after{
    content:"";
    position:absolute; inset:-40%;
    background: linear-gradient(120deg, transparent 30%, rgba(0,255,255,.25), transparent 70%);
    transform: rotate(12deg);
    animation: sheen 3.4s linear infinite;
  }
  @keyframes sheen{
    0%{ transform: translateX(-30%) rotate(12deg); opacity:.0}
    20%{opacity:.9}
    60%{opacity:.9}
    100%{ transform: translateX(30%) rotate(12deg); opacity:0}
  }

  .titleblock{display:flex; flex-direction:column; line-height:1.05}
  .title{
    font-weight:800; letter-spacing:2.2px; font-size:14px;
    color:rgba(0,255,255,.95);
    text-shadow: 0 0 14px rgba(0,255,255,.25);
  }
  .subtitle{
    font-size:12px; color:var(--muted);
  }

  .chips{
    display:flex; gap:8px; align-items:center; flex-wrap:wrap;
  }
  .chip{
    display:flex; align-items:center; gap:8px;
    padding:7px 10px;
    border-radius: 999px;
    background: rgba(6,10,18,.7);
    border:1px solid rgba(176,0,255,.22);
    box-shadow: 0 0 0 1px rgba(0,255,255,.05) inset;
    color: rgba(207,234,255,.85);
    font-size:12px;
  }
  .dot{
    width:8px; height:8px; border-radius:50%;
    background: var(--mint);
    box-shadow: var(--glowM);
  }
  .dot.warn{ background: var(--pink); box-shadow: 0 0 12px rgba(255,47,164,.35);}
  .dot.idle{ background: rgba(207,234,255,.35); box-shadow:none;}

  .spacer{flex:1}

  .actions{
    display:flex; gap:8px; align-items:center;
  }
  .btn{
    display:inline-flex;
    align-items:center;
    gap:10px;
    padding:10px 12px;
    border-radius: 12px;
    background: linear-gradient(180deg, rgba(9,14,24,.85), rgba(6,9,16,.65));
    border:1px solid rgba(0,255,255,.18);
    color:rgba(207,234,255,.92);
    cursor:pointer;
    box-shadow: 0 0 0 1px rgba(176,0,255,.12) inset, 0 10px 28px rgba(0,0,0,.55);
    transition: transform .15s ease, border-color .15s ease, box-shadow .15s ease;
    user-select:none;
  }
  .btn:hover{
    transform: translateY(-1px);
    border-color: rgba(255,47,164,.35);
    box-shadow: var(--glowC);
  }
  .btn.primary{
    border-color: rgba(0,255,255,.35);
    box-shadow: var(--glowC);
  }
  .btn svg{width:16px; height:16px; opacity:.9}

  /* main content */
  .main{
    display:grid;
    grid-template-columns: 360px 1fr;
    gap:12px;
    padding:12px;
    min-height:calc(100dvh - 64px);
    height:auto;
  }

  /* left drawer panel */
  .panel{
    border-radius: var(--r);
    background: linear-gradient(180deg, rgba(10,14,24,.8), rgba(5,7,12,.7));
    border:1px solid rgba(176,0,255,.22);
    box-shadow: var(--shadow);
    overflow:hidden;
    display:flex;
    flex-direction:column;
    min-height:0;
  }
  .panelHeader{
    padding:12px 14px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    border-bottom:1px solid rgba(176,0,255,.18);
    background: rgba(0,0,0,.12);
  }
  .panelHeader .h{
    font-weight:800;
    letter-spacing:1.6px;
    font-size:12px;
    color: rgba(0,255,255,.9);
  }
  .panelBody{ padding:12px 14px; overflow:auto; }

  .fieldRow{
    display:flex; gap:10px; align-items:center;
    margin: 10px 0;
  }
  .fieldRow label{
    width:86px;
    font-size:12px;
    color: var(--muted);
  }
  .input, select{
    flex:1;
    background: rgba(0,0,0,.35);
    border:1px solid rgba(0,255,255,.16);
    color: rgba(207,234,255,.92);
    border-radius: 12px;
    padding:10px 10px;
    outline:none;
    box-shadow: 0 0 0 1px rgba(176,0,255,.10) inset;
  }
  .input:focus, select:focus{
    border-color: rgba(255,47,164,.35);
    box-shadow: var(--glowP);
  }

  .seg{
    display:flex;
    gap:8px;
    flex-wrap:wrap;
  }
  .seg button{
    flex:1;
    min-width: 74px;
    padding:9px 10px;
    border-radius: 14px;
    border:1px solid rgba(176,0,255,.22);
    background: rgba(0,0,0,.25);
    color: rgba(207,234,255,.9);
    cursor:pointer;
    transition: .15s ease;
  }
  .seg button.active{
    border-color: rgba(0,255,255,.35);
    box-shadow: var(--glowC);
    color: rgba(0,255,255,.92);
  }
  .seg button:hover{
    border-color: rgba(255,47,164,.35);
    box-shadow: var(--glowP);
  }

  .list{
    margin-top: 10px;
    display:flex;
    flex-direction:column;
    gap:10px;
  }
  .camItem{
    padding:10px;
    border-radius: 14px;
    border:1px solid rgba(176,0,255,.18);
    background: rgba(0,0,0,.22);
    box-shadow: 0 0 0 1px rgba(0,255,255,.06) inset;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
  }
  .camMeta{
    display:flex;
    flex-direction:column;
    gap:4px;
    min-width:0;
  }
  .camName{
    font-weight:800;
    font-size:12px;
    color: rgba(58,255,163,.95);
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  .camUrl{
    font-size:11px;
    color: var(--muted);
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  .pill{
    padding:6px 8px;
    border-radius: 999px;
    font-size:10px;
    border:1px solid rgba(0,255,255,.20);
    color: rgba(0,255,255,.85);
    background: rgba(0,0,0,.18);
  }
  .pill.rtsp{ border-color: rgba(255,47,164,.25); color: rgba(255,47,164,.9); }
  .miniBtns{ display:flex; gap:8px; }
  .miniBtn{
    width:30px; height:30px;
    border-radius: 12px;
    border:1px solid rgba(0,255,255,.16);
    background: rgba(0,0,0,.18);
    cursor:pointer;
    display:grid;
    place-items:center;
    transition:.15s ease;
  }
  .miniBtn:hover{ border-color: rgba(255,47,164,.35); box-shadow: var(--glowP); transform: translateY(-1px); }
  .miniBtn svg{width:14px; height:14px; opacity:.9}

  /* grid */
  .gridWrap{
    border-radius: var(--r);
    border:1px solid rgba(176,0,255,.22);
    background: linear-gradient(180deg, rgba(10,14,24,.55), rgba(5,7,12,.35));
    box-shadow: var(--shadow);
    overflow:hidden;
    min-height:0;
    display:flex;
    flex-direction:column;
  }
  .gridHeader{
    padding:10px 12px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    border-bottom:1px solid rgba(176,0,255,.18);
    background: rgba(0,0,0,.12);
  }
  .gridHeader .left{
    display:flex; align-items:center; gap:10px;
  }
  .gridHeader .left .h{
    font-weight:800;
    letter-spacing:1.6px;
    font-size:12px;
    color: rgba(0,255,255,.92);
  }
  .gridHeader .right{
    display:flex; align-items:center; gap:8px; flex-wrap:wrap;
  }

  .grid{
    padding:10px;
    display:grid;
    gap:10px;
    grid-template-columns: repeat(2, 1fr);
    overflow:auto;
    min-height:0;
  }
  .grid.g1{ grid-template-columns: 1fr; }
  .grid.g2{ grid-template-columns: repeat(2, 1fr); }
  .grid.g3{ grid-template-columns: repeat(3, 1fr); }
  .grid.gW{ grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); }

  /* tile */
  .tile{
    position:relative;
    border-radius: 18px;
    overflow:hidden;
    background:
      radial-gradient(400px 180px at 35% 15%, rgba(0,255,255,.08), transparent 60%),
      radial-gradient(380px 200px at 85% 80%, rgba(176,0,255,.10), transparent 60%),
      rgba(0,0,0,.35);
    border:1px solid rgba(176,0,255,.25);
    box-shadow: 0 0 0 1px rgba(0,255,255,.05) inset, var(--shadow);
    min-height: 220px;
  }
  .tile.active{
    border-color: rgba(0,255,255,.35);
    box-shadow: 0 0 0 1px rgba(0,255,255,.10) inset, var(--glowC), var(--shadow);
  }
  .media{
    position:absolute; inset:0;
    width:100%; height:100%;
    object-fit:cover;
    background: rgba(0,0,0,.25);
  }

  /* HUD overlay */
  .hud{
    position:absolute; inset:0;
    display:flex;
    flex-direction:column;
    justify-content:space-between;
    pointer-events:none;
  }
  .hudTop{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    padding:10px 10px 8px 10px;
    background: linear-gradient(180deg, rgba(0,0,0,.62), rgba(0,0,0,0));
  }
  .hudTop .name{
    display:flex; align-items:center; gap:8px;
    min-width:0;
    font-weight:800;
    font-size:12px;
    color: rgba(58,255,163,.95);
    text-shadow: 0 0 12px rgba(58,255,163,.20);
  }
  .hudTop .name span{
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  .hudTop .meta{
    font-size:11px;
    color: rgba(207,234,255,.75);
    display:flex; gap:10px; align-items:center;
  }
  .hudTop .tag{
    padding:6px 10px;
    border-radius:999px;
    border:1px solid rgba(0,255,255,.16);
    background: rgba(0,0,0,.28);
    color: rgba(0,255,255,.9);
  }
  .hudTop .tag.rtsp{ border-color: rgba(255,47,164,.25); color: rgba(255,47,164,.9); }
  .hudBottom{
    padding:10px;
    display:flex;
    align-items:flex-end;
    justify-content:space-between;
    gap:10px;
    background: linear-gradient(0deg, rgba(0,0,0,.62), rgba(0,0,0,0));
  }
  .hudBottom .statusline{
    font-size:11px;
    color: rgba(207,234,255,.75);
    display:flex; align-items:center; gap:8px;
  }
  .hudBottom .controls{
    pointer-events:auto;
    display:flex;
    gap:8px;
    align-items:center;
  }
  .ctl{
    width:34px; height:34px;
    border-radius: 14px;
    border:1px solid rgba(0,255,255,.16);
    background: rgba(0,0,0,.25);
    cursor:pointer;
    display:grid;
    place-items:center;
    box-shadow: 0 0 0 1px rgba(176,0,255,.10) inset;
    transition:.15s ease;
  }
  .ctl:hover{
    transform: translateY(-1px);
    border-color: rgba(255,47,164,.35);
    box-shadow: var(--glowP);
  }
  .ctl svg{width:16px; height:16px; opacity:.95}

  .badge{
    padding:6px 10px;
    border-radius: 999px;
    border:1px solid rgba(176,0,255,.22);
    background: rgba(0,0,0,.22);
    color: rgba(207,234,255,.85);
  }
  .badge.ok{ border-color: rgba(58,255,163,.25); color: rgba(58,255,163,.95); }
  .badge.warn{ border-color: rgba(255,47,164,.25); color: rgba(255,47,164,.95); }

  /* modal */
  .modalBackdrop{
    position:fixed; inset:0;
    background: rgba(0,0,0,.6);
    display:none;
    align-items:center;
    justify-content:center;
    padding:14px;
    z-index: 50;
  }
  .modal{
    width:min(720px, 100%);
    border-radius: 20px;
    overflow:hidden;
    border:1px solid rgba(176,0,255,.24);
    box-shadow: 0 0 0 1px rgba(0,255,255,.07) inset, var(--shadow), var(--glowP);
    background: linear-gradient(180deg, rgba(10,14,24,.92), rgba(5,7,12,.85));
    backdrop-filter: blur(12px);
  }
  .modalHead{
    padding:12px 14px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    border-bottom:1px solid rgba(176,0,255,.18);
  }
  .modalHead .h{
    font-weight:900;
    letter-spacing:1.8px;
    font-size:12px;
    color: rgba(0,255,255,.92);
  }
  .modalBody{ padding:14px; }
  .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
  .help{
    font-size:12px;
    color: rgba(207,234,255,.72);
    line-height:1.45;
    padding:10px 12px;
    border-radius: 14px;
    border:1px solid rgba(0,255,255,.14);
    background: rgba(0,0,0,.18);
  }
  .footerRow{
    display:flex;
    justify-content:flex-end;
    gap:10px;
    padding:12px 14px;
    border-top:1px solid rgba(176,0,255,.18);
    background: rgba(0,0,0,.12);
  }
  .btn.flat{
    border-color: rgba(207,234,255,.18);
  }

  /* responsive */
  @media (max-width: 980px){
    .main{ grid-template-columns: 1fr; }
    .brand{ min-width: 0; }
  }
</style>
</head>
<body>
<div class="app">
  <div class="topbar">
    <div class="brand">
      <div class="logo"></div>
      <div class="titleblock">
        <div class="title">NET_NiNjA :: CAM GRID</div>
        <div class="subtitle">HLS / HTTP / MJPEG | RTSP requires gateway (MediaMTX → HLS/WebRTC)</div>
      </div>
    </div>

    <div class="chips">
      <div class="chip"><span id="chipDot" class="dot idle"></span><span id="chipState">IDLE</span></div>
      <div class="chip">CAMS: <b id="camCount">0</b></div>
      <div class="chip">LIVE: <b id="liveCount">0</b></div>
    </div>

    <div class="spacer"></div>

    <div class="actions">
      <div class="btn" id="btnBackApp" title="Return to app tabs" aria-label="Back to app tabs">
        <svg viewBox="0 0 24 24" fill="none"><path d="M15 6l-6 6 6 6" stroke="rgba(0,255,255,.9)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
        Back
      </div>
      <div class="btn" id="btnDiscover" title="Hook this to your scan results / ONVIF backend">
        <!-- radar icon -->
        <svg viewBox="0 0 24 24" fill="none"><path d="M12 2a10 10 0 1 0 10 10" stroke="rgba(0,255,255,.9)" stroke-width="2" stroke-linecap="round"/><path d="M12 12l6-6" stroke="rgba(255,47,164,.9)" stroke-width="2" stroke-linecap="round"/><circle cx="12" cy="12" r="2" fill="rgba(58,255,163,.9)"/></svg>
        Discover
      </div>
      <div class="btn primary" id="btnAdd">
        <!-- plus -->
        <svg viewBox="0 0 24 24" fill="none"><path d="M12 5v14M5 12h14" stroke="rgba(0,255,255,.9)" stroke-width="2" stroke-linecap="round"/></svg>
        Add Camera
      </div>
    </div>
  </div>

  <div class="main">
    <!-- left panel -->
    <div class="panel">
      <div class="panelHeader">
        <div class="h">CONTROL DECK</div>
        <div class="chip" style="padding:6px 10px">
          GRID:
          <b id="gridLabel">2×</b>
        </div>
      </div>
      <div class="panelBody">
        <div class="fieldRow">
          <label>Layout</label>
          <div class="seg">
            <button class="active" data-grid="g2">2×2</button>
            <button data-grid="g3">3×3</button>
            <button data-grid="g1">Focus</button>
            <button data-grid="gW">Wall</button>
          </div>
        </div>

        <div class="fieldRow">
          <label>Mute</label>
          <select id="muteMode">
            <option value="all" selected>Mute all tiles</option>
            <option value="focus">Mute except focused</option>
            <option value="none">Allow audio (not advised)</option>
          </select>
        </div>

        <div class="fieldRow">
          <label>Autoplay</label>
          <select id="autoPlayMode">
            <option value="on" selected>On</option>
            <option value="off">Off</option>
          </select>
        </div>

        <div class="fieldRow">
          <label>Reconnect</label>
          <select id="reconnectMode">
            <option value="on" selected>Auto (3s backoff)</option>
            <option value="off">Manual only</option>
          </select>
        </div>

        <div class="fieldRow">
          <label>Theme</label>
          <select id="accentMode">
            <option value="cyan" selected>Cyan primary</option>
            <option value="pink">Pink alerts</option>
            <option value="mint">Mint status</option>
          </select>
        </div>

        <div class="panelHeader" style="margin-top:12px;border-radius:14px;">
          <div class="h">CAMERA LIST</div>
          <div class="chip" style="padding:6px 10px"><span class="dot"></span> READY</div>
        </div>

        <div id="camList" class="list"></div>
      </div>
    </div>

    <!-- grid -->
    <div class="gridWrap">
      <div class="gridHeader">
        <div class="left">
          <div class="h">LIVE GRID</div>
          <span id="gridStatus" class="badge ok">STANDBY</span>
        </div>
        <div class="right">
          <span class="chip">Latency: <b id="latency">~</b></span>
          <span class="chip">Drops: <b id="drops">0</b></span>
          <span class="chip">Reconnects: <b id="reconnects">0</b></span>
          <div class="btn" id="btnAllReconnect">
            <svg viewBox="0 0 24 24" fill="none"><path d="M21 12a9 9 0 1 1-3-6.7" stroke="rgba(0,255,255,.9)" stroke-width="2" stroke-linecap="round"/><path d="M21 3v6h-6" stroke="rgba(255,47,164,.9)" stroke-width="2" stroke-linecap="round"/></svg>
            Reconnect All
          </div>
        </div>
      </div>

      <div id="grid" class="grid g2"></div>
    </div>
  </div>
</div>

<!-- Add Camera Modal -->
<div id="modalBackdrop" class="modalBackdrop">
  <div class="modal">
    <div class="modalHead">
      <div class="h">ADD CAMERA</div>
      <div class="btn flat" id="btnCloseModal">
        <svg viewBox="0 0 24 24" fill="none"><path d="M6 6l12 12M18 6L6 18" stroke="rgba(207,234,255,.85)" stroke-width="2" stroke-linecap="round"/></svg>
        Close
      </div>
    </div>
    <div class="modalBody">
      <div class="grid2">
        <div>
          <div class="fieldRow">
            <label>Name</label>
            <input class="input" id="camName" placeholder="e.g. Garage / Alfred Phone / Doorbell" />
          </div>

          <div class="fieldRow">
            <label>Type</label>
            <select id="camType">
              <option value="hls">HLS (.m3u8)</option>
              <option value="http">HTTP video (mp4/web)</option>
              <option value="mjpeg">MJPEG (img stream)</option>
              <option value="webrtc">WebRTC (URL)</option>
              <option value="rtsp">RTSP (needs gateway)</option>
            </select>
          </div>

          <div class="fieldRow">
            <label>URL</label>
            <input class="input" id="camUrl" placeholder="https://...m3u8  |  http://.../mjpeg  |  webrtc://..." />
          </div>

          <div class="fieldRow">
            <label>User</label>
            <input class="input" id="camUser" placeholder="optional" />
          </div>

          <div class="fieldRow">
            <label>Pass</label>
            <input class="input" id="camPass" type="password" placeholder="optional" />
          </div>
        </div>

        <div class="help">
          <b style="color:rgba(0,255,255,.92);">Reality check</b><br/>
          Browsers don’t play RTSP directly. If your camera is RTSP-only, run a gateway like <b>MediaMTX</b> to output HLS/WebRTC.<br/><br/>
          <b style="color:rgba(58,255,163,.92);">Good sources:</b><br/>
          • Alfred / many apps: often HLS or HTTP relay<br/>
          • IP Webcam (Android): MJPEG/HTTP<br/>
          • DroidCamX: HTTP/MJPEG depending on mode<br/><br/>
          This dashboard is designed to be embedded in a WebView and fed a camera list from NET_NiNjA.
        </div>
      </div>
    </div>
    <div class="footerRow">
      <div class="btn" id="btnAddDemo">
        <svg viewBox="0 0 24 24" fill="none"><path d="M4 7h16M4 12h16M4 17h10" stroke="rgba(0,255,255,.9)" stroke-width="2" stroke-linecap="round"/></svg>
        Add Demo
      </div>
      <div class="btn primary" id="btnSaveCam">
        <svg viewBox="0 0 24 24" fill="none"><path d="M5 12l4 4L19 6" stroke="rgba(0,255,255,.9)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
        Save Camera
      </div>
    </div>
  </div>
</div>

<script>
/**
 * NET_NiNjA Camera Dashboard
 * - Single-file UI
 * - HLS/HTTP/WebRTC (as URL)/MJPEG supported
 * - RTSP is listed but requires gateway (MediaMTX)
 * - Per tile controls: reconnect, fullscreen, snapshot hook
 */

const ICON = {
  play: `<svg viewBox="0 0 24 24" fill="none"><path d="M8 5l12 7-12 7V5z" fill="rgba(0,255,255,.9)"/></svg>`,
  pause:`<svg viewBox="0 0 24 24" fill="none"><path d="M7 5h4v14H7zM13 5h4v14h-4z" fill="rgba(255,47,164,.9)"/></svg>`,
  rec:  `<svg viewBox="0 0 24 24" fill="none"><circle cx="12" cy="12" r="5" fill="rgba(255,47,164,.9)"/></svg>`,
  snap: `<svg viewBox="0 0 24 24" fill="none"><path d="M9 7l1-2h4l1 2h3a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h3z" stroke="rgba(58,255,163,.95)" stroke-width="2"/><circle cx="12" cy="13" r="3" stroke="rgba(0,255,255,.95)" stroke-width="2"/></svg>`,
  full: `<svg viewBox="0 0 24 24" fill="none"><path d="M8 3H3v5M16 3h5v5M8 21H3v-5M16 21h5v-5" stroke="rgba(0,255,255,.95)" stroke-width="2" stroke-linecap="round"/></svg>`,
  link: `<svg viewBox="0 0 24 24" fill="none"><path d="M10 13a5 5 0 0 1 0-7l1-1a5 5 0 0 1 7 7l-1 1" stroke="rgba(0,255,255,.9)" stroke-width="2" stroke-linecap="round"/><path d="M14 11a5 5 0 0 1 0 7l-1 1a5 5 0 0 1-7-7l1-1" stroke="rgba(255,47,164,.9)" stroke-width="2" stroke-linecap="round"/></svg>`,
  refresh:`<svg viewBox="0 0 24 24" fill="none"><path d="M21 12a9 9 0 1 1-3-6.7" stroke="rgba(0,255,255,.9)" stroke-width="2" stroke-linecap="round"/><path d="M21 3v6h-6" stroke="rgba(255,47,164,.9)" stroke-width="2" stroke-linecap="round"/></svg>`,
  trash:`<svg viewBox="0 0 24 24" fill="none"><path d="M6 7h12M9 7V5h6v2m-8 0l1 14h8l1-14" stroke="rgba(255,47,164,.9)" stroke-width="2" stroke-linecap="round"/></svg>`
};

const state = {
  cams: [],
  focusedId: null,
  drops: 0,
  reconnects: 0,
  live: 0,
  reconnectMode: "on",
  autoPlay: true,
  muteMode: "all"
};
const CAM_STORAGE_KEY = "netninja:cameras:v1";

// demo seeds (good-looking, stable HLS test)
const DEFAULT_DEMO = {
  name: "Demo HLS",
  type: "hls",
  url: "https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8"
};

const elGrid = document.getElementById("grid");
const elList = document.getElementById("camList");
const chipState = document.getElementById("chipState");
const chipDot = document.getElementById("chipDot");
const camCount = document.getElementById("camCount");
const liveCount = document.getElementById("liveCount");
const dropsEl = document.getElementById("drops");
const recEl = document.getElementById("reconnects");
const latencyEl = document.getElementById("latency");
const gridStatus = document.getElementById("gridStatus");

document.getElementById("btnBackApp").onclick = () => requestAppTab("dashboard");
document.getElementById("btnAdd").onclick = () => openModal(true);
document.getElementById("btnCloseModal").onclick = () => openModal(false);
document.getElementById("btnAddDemo").onclick = () => {
  document.getElementById("camName").value = DEFAULT_DEMO.name;
  document.getElementById("camType").value = DEFAULT_DEMO.type;
  document.getElementById("camUrl").value = DEFAULT_DEMO.url;
};
document.getElementById("btnSaveCam").onclick = addCamFromModal;
document.getElementById("modalBackdrop").addEventListener("click", (e) => {
  if(e.target.id === "modalBackdrop") openModal(false);
});

["camName", "camType", "camUrl", "camUser", "camPass"].forEach((id) => {
  const el = document.getElementById(id);
  if(!el) return;
  el.addEventListener("keydown", (e) => {
    if(e.key === "Enter"){
      e.preventDefault();
      addCamFromModal();
    }
  });
});

window.addEventListener("keydown", (e) => {
  if(e.key === "Escape") openModal(false);
});

document.getElementById("btnAllReconnect").onclick = () => {
  document.querySelectorAll(".tile").forEach(tile => {
    const id = tile.dataset.id;
    reconnectTile(id, true);
  });
};

document.getElementById("btnDiscover").onclick = () => {
  // Hook point: feed scan results from NET_NiNjA into window.NetNinjaCams.setCameras(...)
  flashStatus("DISCOVER: awaiting scan feed", "warn");
};

document.getElementById("muteMode").onchange = (e) => {
  state.muteMode = e.target.value;
  applyMutePolicy();
};
document.getElementById("autoPlayMode").onchange = (e) => {
  state.autoPlay = (e.target.value === "on");
  renderAll();
};
document.getElementById("reconnectMode").onchange = (e) => {
  state.reconnectMode = e.target.value;
};

document.querySelectorAll(".seg button").forEach(b => {
  b.onclick = () => {
    document.querySelectorAll(".seg button").forEach(x => x.classList.remove("active"));
    b.classList.add("active");
    setGrid(b.dataset.grid);
  };
});

function setGrid(gridClass){
  elGrid.className = "grid " + gridClass;
  document.getElementById("gridLabel").textContent =
    gridClass === "g1" ? "FOCUS" :
    gridClass === "g2" ? "2×2" :
    gridClass === "g3" ? "3×3" : "WALL";
}

function openModal(show){
  document.getElementById("modalBackdrop").style.display = show ? "flex" : "none";
}

function safeUuid(){
  if(window.crypto && typeof window.crypto.randomUUID === "function"){
    return window.crypto.randomUUID();
  }
  const now = Date.now().toString(36);
  const rand = Math.random().toString(36).slice(2, 11);
  return `cam-${now}-${rand}`;
}

function normalizeType(type){
  const value = String(type || "hls").toLowerCase();
  const allowed = new Set(["hls", "http", "mjpeg", "webrtc", "rtsp"]);
  return allowed.has(value) ? value : "hls";
}

function isSupportedCameraUrl(url){
  const value = String(url || "").trim();
  if(!value) return false;
  if(value.startsWith("webrtc://") || value.startsWith("rtsp://")) return true;
  if(!window.URL) return true;
  try {
    const parsed = new URL(value, window.location.href);
    return ["http:", "https:", "file:", "blob:"].includes(parsed.protocol);
  } catch {
    return false;
  }
}

function normalizeCamera(input){
  return {
    id: input.id || safeUuid(),
    name: (input.name || "Camera").toString().trim() || "Camera",
    type: normalizeType(input.type),
    url: String(input.url || "").trim(),
    user: input.user ? String(input.user).trim() : null,
    pass: input.pass ? String(input.pass).trim() : null,
    source: input.source === "backend" ? "backend" : "manual",
    lastErr: null,
    playing: false,
    lastStart: 0
  };
}

function saveManualCameras(){
  try {
    const manual = state.cams
      .filter(c => c.source !== "backend")
      .map(({ id, name, type, url, user, pass }) => ({ id, name, type, url, user, pass, source: "manual" }));
    window.localStorage.setItem(CAM_STORAGE_KEY, JSON.stringify(manual));
  } catch {
    // Storage may be unavailable in strict WebView modes.
  }
}

function loadManualCameras(){
  try {
    const raw = window.localStorage.getItem(CAM_STORAGE_KEY);
    const parsed = raw ? JSON.parse(raw) : [];
    if(!Array.isArray(parsed)) return [];
    return parsed
      .map(normalizeCamera)
      .filter(cam => isSupportedCameraUrl(cam.url));
  } catch {
    return [];
  }
}

function requestAppTab(tab){
  try {
    if(window.parent && window.parent !== window){
      window.parent.postMessage({ source: "netninja-cam", type: "switch-tab", tab }, "*");
    }
  } catch {
    // noop
  }
}

function addCamFromModal(){
  const name = document.getElementById("camName").value.trim() || "Unnamed Cam";
  const type = document.getElementById("camType").value;
  const url = document.getElementById("camUrl").value.trim();
  const user = document.getElementById("camUser").value.trim();
  const pass = document.getElementById("camPass").value.trim();

  if(!isSupportedCameraUrl(url)){
    flashStatus("Use a valid camera URL", "warn");
    return;
  }

  const duplicate = state.cams.find(c => c.url === url);
  if(duplicate){
    state.focusedId = duplicate.id;
    renderAll();
    openModal(false);
    flashStatus("Camera already exists", "warn");
    return;
  }

  const cam = normalizeCamera({
    id: safeUuid(),
    name, type, url,
    user: user || null,
    pass: pass || null,
    source: "manual"
  });
  state.cams.unshift(cam);
  state.focusedId = cam.id;
  saveManualCameras();
  openModal(false);
  renderAll();
  flashStatus("Camera added", "ok");
}

function renderAll(){
  // update counters
  camCount.textContent = state.cams.length;
  dropsEl.textContent = String(state.drops);
  recEl.textContent = String(state.reconnects);

  // render list + grid
  renderList();
  renderGrid();

  // update live count
  const live = state.cams.filter(c => c.playing).length;
  state.live = live;
  liveCount.textContent = live;

  if(state.cams.length === 0){
    chipState.textContent = "IDLE";
    chipDot.className = "dot idle";
    gridStatus.className = "badge ok";
    gridStatus.textContent = "STANDBY";
  } else {
    chipState.textContent = "RUNNING";
    chipDot.className = "dot";
    gridStatus.className = live ? "badge ok" : "badge warn";
    gridStatus.textContent = live ? "LIVE" : "NO STREAM";
  }

  applyMutePolicy();
}

function renderList(){
  elList.innerHTML = "";
  state.cams.forEach(cam => {
    const item = document.createElement("div");
    item.className = "camItem";
    item.innerHTML = `
      <div class="camMeta">
        <div class="camName">${escapeHtml(cam.name)}</div>
        <div class="camUrl">${escapeHtml(cam.url)}</div>
      </div>
      <div style="display:flex;align-items:center;gap:10px;">
        <div class="pill ${cam.type === "rtsp" ? "rtsp": ""}">${cam.type.toUpperCase()}</div>
        <div class="miniBtns">
          <div class="miniBtn" title="Focus" data-act="focus">${ICON.link}</div>
          <div class="miniBtn" title="Reconnect" data-act="reconnect">${ICON.refresh}</div>
          <div class="miniBtn" title="Remove" data-act="remove">${ICON.trash}</div>
        </div>
      </div>
    `;
    item.querySelector('[data-act="focus"]').onclick = () => { state.focusedId = cam.id; renderAll(); };
    item.querySelector('[data-act="reconnect"]').onclick = () => reconnectTile(cam.id, true);
    item.querySelector('[data-act="remove"]').onclick = () => removeCam(cam.id);
    elList.appendChild(item);
  });
}

function renderGrid(){
  elGrid.innerHTML = "";
  state.cams.forEach(cam => {
    const tile = document.createElement("div");
    tile.className = "tile" + (cam.id === state.focusedId ? " active":"");
    tile.dataset.id = cam.id;

    // media element: video for hls/http/webrtc, img for mjpeg
    let media;
    if(cam.type === "mjpeg"){
      media = document.createElement("img");
      media.className = "media";
      media.loading = "lazy";
      media.referrerPolicy = "no-referrer";
      media.src = cam.url;
      cam.playing = true; // MJPEG is "playing" if it has src
    } else {
      media = document.createElement("video");
      media.className = "media";
      media.playsInline = true;
      media.autoplay = state.autoPlay;
      media.muted = true;
      media.controls = false;
      media.preload = "metadata";

      // HLS: if browser supports native, it'll play. If not, it still shows UI with honest status.
      // (We’re not pulling hls.js from a CDN here on purpose, so it stays truly single-file/offline safe.)
      media.src = cam.url;

      media.onplaying = () => { cam.playing = true; cam.lastErr = null; updateLiveStats(); };
      media.onstalled = () => { cam.playing = false; cam.lastErr = "stalled"; dropAndMaybeReconnect(cam.id); };
      media.onerror = () => { cam.playing = false; cam.lastErr = "error"; dropAndMaybeReconnect(cam.id); };

      // start attempt
      if(state.autoPlay){
        cam.lastStart = performance.now();
        media.play().catch(() => {
          // autoplay restrictions, keep quiet but track status
          cam.playing = false;
          cam.lastErr = "autoplay_blocked";
          updateLiveStats();
        });
      }
    }

    const hud = document.createElement("div");
    hud.className = "hud";

    const tagClass = cam.type === "rtsp" ? "tag rtsp" : "tag";
    const status = cam.lastErr ? `ERR: ${cam.lastErr}` : (cam.playing ? "OK" : "CONNECTING");
    const statusBadge = cam.lastErr ? `<span class="badge warn">${status}</span>` : `<span class="badge ok">${status}</span>`;

    hud.innerHTML = `
      <div class="hudTop">
        <div class="name">
          <span>${escapeHtml(cam.name)}</span>
        </div>
        <div class="meta">
          <span class="${tagClass}">${cam.type.toUpperCase()}</span>
          ${statusBadge}
        </div>
      </div>

      <div class="hudBottom">
        <div class="statusline">
          <span class="dot ${cam.lastErr ? "warn": (cam.playing ? "" : "idle")}"></span>
          <span>${escapeHtml(cam.url)}</span>
        </div>
        <div class="controls">
          <button class="ctl" title="Reconnect" data-act="reconnect">${ICON.refresh}</button>
          <button class="ctl" title="Fullscreen" data-act="full">${ICON.full}</button>
          <button class="ctl" title="Snapshot (hook)" data-act="snap">${ICON.snap}</button>
        </div>
      </div>
    `;

    tile.appendChild(media);
    tile.appendChild(hud);

    // interactions
    tile.onclick = (e) => {
      // ignore clicks on buttons
      if(e.target.closest(".ctl")) return;
      state.focusedId = cam.id;
      renderAll();
    };
    tile.querySelector('[data-act="reconnect"]').onclick = (e) => { e.stopPropagation(); reconnectTile(cam.id, true); };
    tile.querySelector('[data-act="full"]').onclick = (e) => { e.stopPropagation(); requestFullscreen(tile); };
    tile.querySelector('[data-act="snap"]').onclick = (e) => { e.stopPropagation(); snapshotTile(cam.id); };

    elGrid.appendChild(tile);
  });

  updateLiveStats();
}

function updateLiveStats(){
  const live = state.cams.filter(c => c.playing).length;
  liveCount.textContent = live;

  // cheap latency estimator: time to first play for focused tile
  const f = state.cams.find(x => x.id === state.focusedId);
  if(f && f.lastStart){
    const ms = Math.max(0, Math.round(performance.now() - f.lastStart));
    latencyEl.textContent = f.playing ? (ms + "ms") : "~";
  } else {
    latencyEl.textContent = "~";
  }
}

function dropAndMaybeReconnect(id){
  state.drops++;
  dropsEl.textContent = String(state.drops);
  updateLiveStats();

  if(state.reconnectMode !== "on") return;
  setTimeout(() => reconnectTile(id, false), 3000);
}

function reconnectTile(id, manual){
  const cam = state.cams.find(c => c.id === id);
  if(!cam) return;

  state.reconnects++;
  recEl.textContent = String(state.reconnects);

  const tile = document.querySelector(`.tile[data-id="${CSS.escape(id)}"]`);
  if(!tile) { renderAll(); return; }

  const media = tile.querySelector(".media");
  cam.lastErr = null;
  cam.playing = false;

  // MJPEG "reconnect": reset src
  if(cam.type === "mjpeg" && media.tagName.toLowerCase() === "img"){
    const src = cam.url;
    media.src = "";
    setTimeout(() => { media.src = src; cam.playing = true; updateLiveStats(); }, 250);
    flashStatus(manual ? "Reconnected MJPEG" : "Auto-reconnect MJPEG", "ok");
    return;
  }

  // Video reconnect
  if(media && media.tagName.toLowerCase() === "video"){
    const v = media;
    const src = cam.url;
    try{
      v.pause();
      v.removeAttribute("src");
      v.load();
      setTimeout(() => {
        v.src = src;
        cam.lastStart = performance.now();
        v.load();
        if(state.autoPlay){
          v.play().catch(() => {
            cam.lastErr = "autoplay_blocked";
            cam.playing = false;
            updateLiveStats();
          });
        }
        flashStatus(manual ? "Reconnect requested" : "Auto-reconnect", "ok");
      }, 250);
    } catch {
      cam.lastErr = "reconnect_failed";
      updateLiveStats();
      flashStatus("Reconnect failed", "warn");
    }
  }
}

function removeCam(id){
  const idx = state.cams.findIndex(c => c.id === id);
  if(idx < 0) return;
  state.cams.splice(idx, 1);
  saveManualCameras();
  if(state.focusedId === id){
    state.focusedId = state.cams[0]?.id || null;
  }
  renderAll();
  flashStatus("Camera removed", "ok");
}

function requestFullscreen(el){
  const req = el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen;
  if(req) req.call(el);
}

function snapshotTile(id){
  // Hook: In WebView, you can intercept this to call Android native snapshot capture
  // For browser-only, we can attempt to draw <video> to canvas if CORS allows it.
  const cam = state.cams.find(c => c.id === id);
  if(!cam) return;

  const tile = document.querySelector(`.tile[data-id="${CSS.escape(id)}"]`);
  if(!tile) return;

  const v = tile.querySelector("video");
  if(!v){
    flashStatus("Snapshot: MJPEG needs backend capture", "warn");
    return;
  }

  try{
    const canvas = document.createElement("canvas");
    canvas.width = v.videoWidth || 1280;
    canvas.height = v.videoHeight || 720;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(v, 0, 0, canvas.width, canvas.height);
    const url = canvas.toDataURL("image/png");
    const a = document.createElement("a");
    a.href = url;
    a.download = (cam.name || "snapshot") + ".png";
    a.click();
    flashStatus("Snapshot saved", "ok");
  } catch {
    flashStatus("Snapshot blocked by CORS. Use native capture.", "warn");
  }
}

function applyMutePolicy(){
  const vids = document.querySelectorAll("video.media");
  vids.forEach(v => {
    if(state.muteMode === "all") v.muted = true;
    else if(state.muteMode === "none") v.muted = false;
    else {
      // focus only
      const tile = v.closest(".tile");
      const id = tile?.dataset?.id;
      v.muted = (id !== state.focusedId);
    }
  });
}

function flashStatus(text, kind){
  gridStatus.className = "badge " + (kind === "warn" ? "warn":"ok");
  gridStatus.textContent = text.toUpperCase();
  setTimeout(() => {
    const live = state.cams.filter(c => c.playing).length;
    gridStatus.className = live ? "badge ok" : "badge warn";
    gridStatus.textContent = live ? "LIVE" : (state.cams.length ? "NO STREAM" : "STANDBY");
  }, 1800);
}

function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, (c) => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
  }[c]));
}

/**
 * External integration hook (NET_NiNjA -> WebView):
 * window.NetNinjaCams.setCameras([
 *   { name, type: "hls|http|mjpeg|webrtc|rtsp", url, user?, pass? }
 * ])
 */
window.NetNinjaCams = {
  setCameras(list){
    const backend = (list || [])
      .map(x => normalizeCamera({
        id: safeUuid(),
        name: x.name,
        type: x.type,
        url: x.url,
        user: x.user,
        pass: x.pass,
        source: "backend"
      }))
      .filter(x => isSupportedCameraUrl(x.url));
    const manual = loadManualCameras();
    const merged = [...manual, ...backend.filter(b => !manual.some(m => m.url === b.url))];
    state.cams = merged;
    state.focusedId = merged[0]?.id || null;
    renderAll();
    flashStatus("Scan feed loaded", merged.length ? "ok" : "warn");
  }
};

// Seed with persisted cameras, then one demo so it looks alive immediately.
state.cams = loadManualCameras();
if(state.cams.length === 0){
  state.cams = [normalizeCamera({
    id: safeUuid(),
    name: DEFAULT_DEMO.name,
    type: DEFAULT_DEMO.type,
    url: DEFAULT_DEMO.url,
    user: null,
    pass: null,
    source: "manual"
  })];
  saveManualCameras();
}
state.focusedId = state.cams[0]?.id || null;
renderAll();
</script>
</body>
</html>
