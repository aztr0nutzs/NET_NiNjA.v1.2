<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="color-scheme" content="dark" />
  <title>NEONLINK // Speedtest HUD</title>

  
<!-- Theme CSS (provided) -->
<link rel="stylesheet" href="style.css" />

<!-- Overrides to: (1) force true-black background, (2) remove green/purple glows, (3) add subtle HUD effects -->
<style id="theme-overrides">
  :root{
    /* Keep the provided theme, but kill green/purple accents. */
    --primary-color: #00ebff;      /* cyan */
    --secondary-color: #ffae00;    /* amber */
    --green-color: #0a5688;        /* repurpose "green" as steel-blue */
    --price-color: var(--secondary-color);
    --shadow-color: rgba(0,0,0,0); /* no headline glow */
          --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }

  html{ background:#000; }
  body{
    background:#000 !important;
    background-image:none !important;
    color: var(--body-color);
    padding: 1.5rem !important;
    overflow-x:hidden;
    overflow-y:auto;
    -webkit-overflow-scrolling: touch;
    margin: 0;
    min-height: 100vh;
    min-height: 100dvh;
    box-sizing: border-box;
  }
  *, *::before, *::after { box-sizing: border-box; }
  @media (max-width: 720px){
    body{ padding: .6rem !important; }
  }
  @media (max-width: 480px){
    body{ padding: .35rem !important; }
  }

  /* remove glow-y shadows from the base theme */
  h1,h2,h3,h4,h5{ text-shadow:none !important; }
  nav li:hover:after{ box-shadow:none !important; }
  .widjet:after{ box-shadow:none !important; }
  .btn, .btn-2{ box-shadow:none !important; }

  /* Subtle cyber HUD overlays (cyan only) */
  .fx-grid, .fx-scan{ position:fixed; inset:0; pointer-events:none; z-index:0; }
  .fx-grid{
    background:
      linear-gradient(to right, rgba(0,235,255,.045) 1px, transparent 1px),
      linear-gradient(to bottom, rgba(0,235,255,.035) 1px, transparent 1px);
    background-size: 96px 96px;
    opacity:.35;
    mask-image: radial-gradient(circle at 50% 35%, rgba(0,0,0,1), rgba(0,0,0,.35) 55%, rgba(0,0,0,0) 78%);
  }
  .fx-scan{
    background: repeating-linear-gradient(
      180deg,
      rgba(255,255,255,.018) 0px,
      rgba(255,255,255,.018) 1px,
      transparent 2px,
      transparent 6px
    );
    opacity:.14;
    mix-blend-mode: screen;
    animation: scanShift 12s linear infinite;
  }
  @keyframes scanShift{ from{transform:translateY(0)} to{transform:translateY(140px)} }

  /* App layout */
  .app{ position:relative; z-index:1; }
  .topbar{ margin-bottom: 1rem; }
  .topbar-inner{
    display:flex;
    align-items:center;
    gap: .6rem;
    flex-wrap:wrap;
    padding: .8rem 1rem;
    background: rgba(0,0,0,.55);
    border: 1px solid rgba(0,235,255,.18);
    box-shadow: none;
  }
  .brand h1{ margin:0; font-size: clamp(1rem, 3vw, 1.6rem); letter-spacing:.12em; text-transform:uppercase; color: var(--primary-color); }
  .brand .sub{ margin-top:.3rem; font-size: clamp(.7rem, 2vw, 1.1rem); letter-spacing:.06em; opacity:.75; text-transform:uppercase; }

  .sigil{
    width:42px;height:42px;border-radius: 10px;
    border: 1px solid rgba(0,235,255,.28);
    background:
      radial-gradient(circle at 35% 30%, rgba(0,235,255,.22), transparent 58%),
      linear-gradient(135deg, rgba(0,235,255,.14), rgba(255,174,0,.08));
    position:relative; overflow:hidden;
  }
  .sigil:after{
    content:"";
    position:absolute; inset:-2px;
    background: linear-gradient(90deg, transparent, rgba(0,235,255,.18), transparent);
    transform: translateX(-60%);
    animation: sheen 3.2s ease-in-out infinite;
  }
  @keyframes sheen{ 0%{transform:translateX(-60%)} 55%{transform:translateX(120%)} 100%{transform:translateX(120%)} }

  .pill{
    display:flex; align-items:center; gap:.5rem;
    padding:.5rem .8rem;
    border: 1px solid rgba(0,235,255,.16);
    background: rgba(0,0,0,.35);
    text-transform:uppercase;
    font-size: clamp(.7rem, 2vw, 1.1rem);
    min-width: 0;
    overflow: hidden;
  }
  .pill span{ white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .pill .dot{
    width:10px;height:10px;border-radius: 99px;
    background: var(--secondary-color);
    animation: pulse 1.8s ease-in-out infinite;
  }
  @keyframes pulse{ 0%,100%{transform:scale(1);opacity:1} 50%{transform:scale(.72);opacity:.65} }

  .shell{
    display:grid;
    grid-template-columns: 1.55fr .95fr;
    gap: 1rem;
    align-items:start;
    max-width: 100%;
  }
  @media (max-width: 980px){ .shell{ grid-template-columns:1fr; } }

  .card{ /* mapped to widjet look */
    position:relative;
    background: rgba(22, 104, 159, 0.14);
    border: 1px solid rgba(0,235,255,.18);
    padding: 0;
  }
  .card-header{
    background: rgba(0,0,0,.45);
    padding: .8rem 1rem;
    border-bottom: 1px solid rgba(0,235,255,.14);
    display:flex;
    align-items:flex-end;
    justify-content:space-between;
    gap:.6rem;
    flex-wrap: wrap;
  }
  .title{ margin:0; font-size:clamp(.85rem, 2.2vw, 1.25rem); letter-spacing:.12em; text-transform:uppercase; color: var(--primary-color); }
  .meta{ font-size:clamp(.7rem, 1.8vw, 1.05rem); opacity:.75; text-transform:uppercase; letter-spacing:.06em; }
  .meta b{ color:#fff; font-weight:700; }

  .controls{
    padding: .8rem 1rem;
    display:flex;
    flex-wrap:wrap;
    gap: .6rem;
    align-items:center;
    border-bottom: 1px solid rgba(0,235,255,.10);
    background: rgba(0,0,0,.22);
  }
  button.btn, button.btn-2{
    font-family: 'Jura', sans-serif;
    text-transform:uppercase;
    letter-spacing:.12em;
    border-radius: 0;
    cursor:pointer;
    border: 1px solid rgba(0,235,255,.22);
    font-size: clamp(.7rem, 2vw, .95rem);
  }
  button.btn{
    background: rgba(0,0,0,.25);
    color: var(--primary-color);
    border-left: .2rem solid var(--primary-color);
    padding: .7rem 1.2rem;
  }
  button.btn-2{
    background: rgba(0,0,0,.25);
    color: #fff;
    border: 1px solid rgba(255,174,0,.28);
    padding: .7rem 1.2rem;
  }
  button:disabled{ opacity:.55; cursor:not-allowed; }

  .select, .toggle{
    display:flex;
    align-items:center;
    gap:.5rem;
    padding: .6rem .8rem;
    border: 1px solid rgba(0,235,255,.14);
    background: rgba(0,0,0,.20);
    min-width: 0;
  }
  .select label, .toggle label{
    font-size: clamp(.7rem, 1.8vw, 1.0rem);
    opacity:.75;
    text-transform:uppercase;
    letter-spacing:.10em;
    white-space: nowrap;
  }
  select{
    background: transparent;
    border: none;
    color: #fff;
    outline: none;
    font-size: clamp(.7rem, 1.8vw, 1.05rem);
    letter-spacing:.08em;
    text-transform:uppercase;
    max-width: 100%;
    min-width: 0;
  }
  @media (max-width: 480px){
    .select, .toggle{ flex: 1 1 100%; }
  }

  .switch{
    width: 44px; height: 22px;
    border: 1px solid rgba(0,235,255,.20);
    background: rgba(0,0,0,.28);
    position:relative;
  }
  .switch:after{
    content:"";
    position:absolute; top:2px; left:2px;
    width:18px; height:18px;
    background: rgba(0,235,255,.75);
    transition: transform .18s ease, background .18s ease;
  }
  .switch.on:after{ transform: translateX(20px); background: rgba(255,174,0,.75); }

  .gauge-wrap{
    padding: .8rem;
    display:grid;
    grid-template-columns: 1.8fr .6fr;
    gap: .8rem;
    align-items:start;
  }
  @media (max-width: 1120px){
    .gauge-wrap{ grid-template-columns: 1fr; }
    .hud{ order: 2; }
  }
  @media (max-width: 780px){ .gauge-wrap{ grid-template-columns: 1fr; padding: .5rem; } }

  .gauge, .hud{
    border: 1px solid rgba(0,235,255,.14);
    background: rgba(0,0,0,.22);
    padding: .6rem;
  }
  .gauge canvas, .chart canvas{
    width:100%;
    height: clamp(160px, 35vw, 300px);
    display:block;
    background: rgba(0,0,0,.35);
    border: 1px solid rgba(0,235,255,.14);
  }
  .readout{
    margin-top: .6rem;
    display:flex;
    align-items:flex-end;
    justify-content:space-between;
    gap: .6rem;
    flex-wrap:wrap;
  }
  .speed-num{
    font-size: clamp(2.4rem, 7vw, 6.6rem);
    line-height: 1;
    color: #fff;
    letter-spacing:.04em;
  }
  .unit, .phase{ font-size: clamp(.7rem, 2vw, 1.05rem); opacity:.78; letter-spacing:.10em; text-transform:uppercase; }
  .phase b{ color: var(--secondary-color); }

  .progress{
    width: clamp(120px, 40vw, 220px); height: 8px;
    border: 1px solid rgba(0,235,255,.14);
    background: rgba(255,255,255,.05);
    position:relative;
    overflow:hidden;
  }
  .progress > i{
    position:absolute; inset:0;
    width:0%;
    background: linear-gradient(90deg, rgba(0,235,255,.75), rgba(255,174,0,.70));
    transition: width .12s linear;
  }

  .hud-grid{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap: .6rem;
  }
  .hud-item{
    border: 1px solid rgba(255,255,255,.10);
    background: rgba(0,0,0,.20);
    padding: .6rem;
    min-height: 60px;
    overflow: hidden;
  }
  .hud-k{ font-size: clamp(.65rem, 1.8vw, 1.0rem); opacity:.75; letter-spacing:.10em; text-transform:uppercase; }
  .hud-v{ margin-top:.4rem; font-size: clamp(1.4rem, 4vw, 2.4rem); color:#fff; letter-spacing:.04em; line-height:1.1; }
  .hud-v small{ font-size: clamp(.65rem, 1.8vw, 1.05rem); opacity:.7; text-transform:uppercase; letter-spacing:.10em; }

  .hud-wide{ grid-column: 1 / -1; min-height: 70px; display:flex; flex-direction:column; gap:.5rem; }
  .signalbar{ height: 8px; border: 1px solid rgba(255,174,0,.18); background: rgba(255,255,255,.05); overflow:hidden; position:relative; }
  .signalbar > i{ position:absolute; inset:0; width:42%; background: linear-gradient(90deg, rgba(255,174,0,.65), rgba(0,235,255,.65)); transition: width .18s ease; }

  .side{ display:flex; flex-direction:column; gap: 1rem; }
  .list{ padding: .8rem 1rem; display:flex; flex-direction:column; gap: .7rem; background: rgba(0,0,0,.18); }
  .row{
    display:flex; align-items:center; justify-content:space-between; gap: .6rem;
    font-size: clamp(.7rem, 1.8vw, 1.05rem); opacity:.8; text-transform:uppercase; letter-spacing:.08em;
    flex-wrap: wrap;
  }
  .row b{ color:#fff; opacity:1; font-weight:700; }
  .tag{
    padding: .4rem .7rem;
    border: 1px solid rgba(0,235,255,.14);
    background: rgba(0,0,0,.25);
    display:flex; align-items:center; gap:.5rem;
    font-size: clamp(.65rem, 1.6vw, 1.0rem);
    white-space: nowrap;
  }
  .tag i{ width:8px; height:8px; border-radius:99px; background: var(--primary-color); display:inline-block; }
  .tag.warn{ border-color: rgba(255,174,0,.22); }
  .tag.warn i{ background: var(--secondary-color); }
  .tag.bad{ border-color: rgba(255,47,77,.22); }
  .tag.bad i{ background: rgba(255,47,77,.85); }
  .tag.good{ border-color: rgba(0,235,255,.22); }
  .tag.good i{ background: var(--primary-color); }

  .chart{ padding: .8rem; background: rgba(0,0,0,.18); }
  .chart canvas{ height: clamp(120px, 28vw, 210px); }

  .footer{
    margin-top: 1rem;
    padding: .8rem 0 0;
    border-top: 1px solid rgba(0,235,255,.12);
    display:flex; justify-content:space-between; gap: .6rem; flex-wrap:wrap;
    font-size: clamp(.65rem, 1.6vw, 1.0rem); text-transform:uppercase; letter-spacing:.08em; opacity:.75;
  }
  .footer a{ color: var(--primary-color); border-bottom: 1px solid rgba(0,235,255,.18); }


  /* ============================================================
     v2 HUD polish: bigger, sharper, more color-coded (no green/purple).
     ============================================================ */

  /* Bigger, more aggressive dial */
  .gauge-wrap{
    max-width: 100%;
    margin: 0 auto;
  }
  .gauge{
    border-radius: 12px;
    padding: .4rem;
    background:
      radial-gradient(1200px 520px at 50% 40%, rgba(0,235,255,.08), rgba(0,0,0,0) 60%),
      radial-gradient(900px 420px at 50% 110%, rgba(255,174,0,.06), rgba(0,0,0,0) 55%),
      #000;
    border: 1px solid rgba(255,255,255,.07);
    box-shadow: 0 12px 40px rgba(0,0,0,.75);
  }
#gaugeCanvas{
    width: 100%;
    height: auto;
    aspect-ratio: 1600 / 860;
    display:block;
    max-height: clamp(160px, 38vw, 500px);
  }

  /* Make readout feel like an instrument cluster */
  .readout{
    gap: .6rem;
    padding: .6rem .8rem !important;
    border-radius: 10px;
    background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
    border: 1px solid rgba(230,251,255,.10);
  }
  .speed-num{
    font-size: clamp(2rem, 7vw, 5rem) !important;
    line-height: 0.95 !important;
    letter-spacing: 0.02em;
    text-shadow: 0 0 12px rgba(0,235,255,.12);
  }
  .unit{
    font-size: clamp(.65rem, 1.8vw, .95rem) !important;
    color: rgba(230,251,255,.72) !important;
  }

  /* Metric tiles: color-coded accents */
  .metric{
    --metric-color: rgba(230,251,255,.18);
    position: relative;
    padding-left: 14px !important;
    border-left: 3px solid var(--metric-color);
    background: linear-gradient(90deg, rgba(0,0,0,.0), rgba(255,255,255,.02));
  }
  .metric-dot{
    position:absolute;
    left: -7px;
    top: 14px;
    width: 10px;
    height: 10px;
    border-radius: 999px;
    background: var(--metric-color);
    box-shadow: 0 0 10px rgba(0,0,0,.65);
  }
  .metric .hud-k{
    display:flex;
    align-items:center;
    gap:.5rem;
    letter-spacing: .12em;
  }
  .metric .hud-v span{
    text-shadow: 0 0 14px rgba(0,0,0,.65);
  }

  /* Per-metric base colors */
  .metric-ping   { --metric-color: rgba(0,235,255,.55); }   /* cyan */
  .metric-jitter { --metric-color: rgba(255,214,0,.55); }   /* yellow */
  .metric-dl     { --metric-color: rgba(0,160,255,.55); }   /* blue */
  .metric-ul     { --metric-color: rgba(255,174,0,.55); }   /* amber */
  .metric-signal { --metric-color: rgba(230,251,255,.35); } /* neutral */

  /* Level states (no green/purple) */
  .level-good  { filter: none; }
  .level-warn  { --metric-color: rgba(255,174,0,.70); }
  .level-bad   { --metric-color: rgba(255,47,77,.75); }

  /* Inline metrics for Loss/Bufferbloat */
  .metric-inline{
    padding: .12rem .45rem;
    border-radius: 999px;
    border: 1px solid rgba(230,251,255,.10);
    background: rgba(255,255,255,.03);
    font-weight: 700;
    letter-spacing: .06em;
  }
  .metric-inline.level-good{ color: rgba(0,235,255,.92); }
  .metric-inline.level-warn{ color: rgba(255,174,0,.95); }
  .metric-inline.level-bad { color: rgba(255,47,77,.95); }

  /* Extra “aggressive” HUD garnish: corner brackets */
  .panel{
    position: relative;
  }
  .panel:before, .panel:after{
    content:"";
    position:absolute;
    width: 26px;
    height: 26px;
    border: 2px solid rgba(230,251,255,.14);
    pointer-events:none;
    opacity: .75;
  }
  .panel:before{
    left: 10px; top: 10px;
    border-right: none; border-bottom: none;
  }
  .panel:after{
    right: 10px; bottom: 10px;
    border-left: none; border-top: none;
  }

  /* ============================================================
     Mobile-specific overrides for iframe embedding
     ============================================================ */
  @media (max-width: 600px){
    .topbar{ margin-bottom: .5rem; }
    .topbar-inner{ padding: .5rem .6rem; gap: .4rem; }
    .brand .sub{ display: none; }
    .sigil{ width: 28px; height: 28px; }
    .spacer{ display: none; }
    .pill{ padding: .3rem .5rem; }

    .controls{ padding: .5rem; gap: .4rem; }
    button.btn{ padding: .5rem .8rem; }
    button.btn-2{ padding: .5rem .8rem; }

    .gauge-wrap{ padding: .3rem; gap: .4rem; }
    .gauge{ padding: .3rem; border-radius: 8px; }
    .hud{ padding: .4rem; }
    .hud-grid{ gap: .4rem; }
    .hud-item{ padding: .4rem; min-height: 44px; }

    .readout{ padding: .4rem .5rem !important; gap: .4rem; }
    .card-header{ padding: .5rem .6rem; }
    .list{ padding: .5rem .6rem; gap: .5rem; }
    .chart{ padding: .4rem; }

    .shell{ gap: .6rem; }
    .side{ gap: .6rem; }

    .row .tag{ padding: .3rem .5rem; }

    .hud-wide .row{ flex-wrap: wrap; gap: .3rem; font-size: clamp(.6rem, 1.5vw, .85rem); }
  }

  @media (max-width: 380px){
    .topbar{ display: none; }
    .controls{ flex-direction: column; align-items: stretch; }
    .controls > button,
    .controls > .select,
    .controls > .toggle{ width: 100%; }
    .hud-grid{ grid-template-columns: 1fr; }
  }


</style>
</head>
<body>
  <div class="fx-grid"></div>
  <div class="fx-scan"></div>

  <div class="app">
    <header class="topbar">
      <div class="topbar-inner">
        <div class="brand">
          <div class="sigil" aria-hidden="true"></div>
          <div>
            <h1 class="glitch" data-text="NEONLINK // SPEEDTEST HUD">NEONLINK // SPEEDTEST HUD</h1>
            <div class="sub">Holographic diagnostic console • cyberpunk UI • “trust me bro” telemetry</div>
          </div>
        </div>

        <div class="spacer"></div>

        <div class="pill" title="Network state (UI-only)">
          <div class="dot"></div>
          <span id="netState">LINK: STABLE • RF: NOMINAL</span>
        </div>
      </div>
    </header>

    <main class="shell">
      <!-- MAIN PANEL -->
      <section class="card">
        <div class="card-header">
          <h2 class="title">Speedometer core</h2>
          <div class="meta">
            <span>Server: <b id="serverName">NEO-1</b></span>
            <span>Mode: <b id="modeLabel">AUTO</b></span>
          </div>
        </div>

        <div class="controls">
          <button class="btn" id="btnStart">Initiate Test</button>
          <button class="btn-2" id="btnAbort" disabled>Abort</button>
          <button class="btn-2" id="btnReset">Reset</button>

          <div class="select">
            <label for="serverSel">uplink node</label>
            <select id="serverSel">
              <option value="neo-1">NEO-1 • Downtown Relay</option>
              <option value="arc-7">ARC-7 • Subnet Spire</option>
              <option value="hex-3">HEX-3 • Industrial Backbone</option>
              <option value="luna-9">LUNA-9 • Edge Satellite</option>
            </select>
          </div>

          <div class="toggle" title="Try real fetch-based measurement (requires endpoints on your domain). Falls back safely.">
            <div class="switch" id="swReal" role="switch" aria-checked="false" tabindex="0"></div>
            <label for="swReal">real test</label>
          </div>

          <div class="toggle" title="Switch gauge to a smaller max range for slower links.">
            <div class="switch" id="swRange" role="switch" aria-checked="false" tabindex="0"></div>
            <label for="swRange">boost precision</label>
          </div>
        </div>

        <div class="gauge-wrap">
          <div class="gauge">
            <canvas id="gaugeCanvas" width="1600" height="860" aria-label="Speedometer gauge"></canvas>
            <div class="readout">
              <div>
                <div class="speed-num"><span id="speedVal">0.00</span></div>
                <div class="unit"><span id="speedUnit">Mbps</span> • <span id="phaseTiny">Idle</span></div>
              </div>

              <div class="phase">
                <div>Status: <b id="phaseLabel">Awaiting command</b></div>
                <div class="progress" aria-label="Phase progress">
                  <i id="phaseBar"></i>
                </div>
              </div>
            </div>
          </div>

          <aside class="hud">
            <div class="hud-grid">
              <div class="hud-item metric metric-ping">
                <span class="metric-dot" aria-hidden="true"></span>
                <div class="hud-k">Ping</div>
                <div class="hud-v"><span id="pingVal">--</span> <small>ms</small></div>
              </div>
              <div class="hud-item metric metric-jitter">
                <span class="metric-dot" aria-hidden="true"></span>
                <div class="hud-k">Jitter</div>
                <div class="hud-v"><span id="jitterVal">--</span> <small>ms</small></div>
              </div>

              <div class="hud-item metric metric-dl">
                <span class="metric-dot" aria-hidden="true"></span>
                <div class="hud-k">Download</div>
                <div class="hud-v"><span id="dlVal">--</span> <small>Mbps</small></div>
              </div>
              <div class="hud-item metric metric-ul">
                <span class="metric-dot" aria-hidden="true"></span>
                <div class="hud-k">Upload</div>
                <div class="hud-v"><span id="ulVal">--</span> <small>Mbps</small></div>
              </div>

              <div class="hud-item hud-wide metric metric-signal">
                <span class="metric-dot" aria-hidden="true"></span>
                <div class="hud-k">Signal integrity</div>
                <div class="signalbar"><i id="sigFill"></i></div>
                <div class="row" style="text-transform:none;letter-spacing:.04em;">
                  <span style="color:rgba(230,251,255,.55)">Loss est.</span>
                  <b id="lossVal" class="metric-inline metric-loss">0.0%</b>
                  <span style="color:rgba(230,251,255,.55)">Bufferbloat</span>
                  <b id="bbVal" class="metric-inline metric-bb">low</b>
                </div>
              </div>
            </div>
          </aside>
        </div>
      </section>

      <!-- SIDE PANEL -->
      <section class="side">
        <section class="card">
          <div class="card-header">
            <h2 class="title">Link analysis</h2>
            <div class="meta">
              <span>Threat: <b id="threatLabel">LOW</b></span>
            </div>
          </div>
          <div class="list">
            <div class="row">
              <span>Uplink route</span>
              <span class="tag good"><i></i><span id="routeTag">Clean</span></span>
            </div>
            <div class="row">
              <span>RF noise</span>
              <span class="tag" id="rfTag"><i></i><span id="rfTxt">Nominal</span></span>
            </div>
            <div class="row">
              <span>Congestion</span>
              <span class="tag warn" id="congTag"><i></i><span id="congTxt">Unknown</span></span>
            </div>
            <div class="row">
              <span>Protocol</span>
              <span class="tag"><i></i><span id="protoTxt">HTTP/2 (sim)</span></span>
            </div>
            <div class="row">
              <span>Notes</span>
              <span style="max-width: 70%; text-align:right; color:rgba(230,251,255,.55); font-family: var(--mono); font-size:clamp(9px, 1.6vw, 11px); line-height:1.25; word-break: break-word;">
                Real tests need same-origin endpoints. Otherwise browsers throw a tantrum.
              </span>
            </div>
          </div>
        </section>

        <section class="card">
          <div class="card-header">
            <h2 class="title">History trace</h2>
            <div class="meta">
              <span>Samples: <b id="histCount">0</b></span>
            </div>
          </div>
          <div class="chart">
            <canvas id="histCanvas" width="900" height="420" aria-label="History chart"></canvas>
          </div>
        </section>
      </section>
    </main>

    <div class="footer">
      <div>© 2099 NEONLINK DIAGNOSTICS • UI renders at human-comfortable contrast (you’re welcome)</div>
      <div>
        <a href="#" id="exportBtn">Export last result</a>
      </div>
    </div>
  </div>

  <script src="../js/api-client.js"></script>
  <script>
    /* ============================================================
       NEONLINK Speedtest HUD
       - Wired to backend speedtest endpoints under /api/v1/speedtest/*
       - Gauge and metrics are updated from real transfer timings.
       ============================================================ */

    const $ = (id)=>document.getElementById(id);

    // Fonts for canvas (CSS vars don’t resolve inside <canvas>).
    const FONT_HUD = '"Jura", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif';
    const FONT_MONO = 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';

    const ui = {
      speedVal: $("speedVal"),
      speedUnit: $("speedUnit"),
      phaseTiny: $("phaseTiny"),
      phaseLabel: $("phaseLabel"),
      phaseBar: $("phaseBar"),
      pingVal: $("pingVal"),
      jitterVal: $("jitterVal"),
      dlVal: $("dlVal"),
      ulVal: $("ulVal"),
      pingBox: document.querySelector(".metric-ping"),
      jitterBox: document.querySelector(".metric-jitter"),
      dlBox: document.querySelector(".metric-dl"),
      ulBox: document.querySelector(".metric-ul"),
      sigBox: document.querySelector(".metric-signal"),
      sigFill: $("sigFill"),
      lossVal: $("lossVal"),
      bbVal: $("bbVal"),
      threatLabel: $("threatLabel"),
      routeTag: $("routeTag"),
      rfTxt: $("rfTxt"),
      congTxt: $("congTxt"),
      protoTxt: $("protoTxt"),
      serverName: $("serverName"),
      modeLabel: $("modeLabel"),
      histCount: $("histCount"),
      netState: $("netState"),
      btnStart: $("btnStart"),
      btnAbort: $("btnAbort"),
      btnReset: $("btnReset"),
      swReal: $("swReal"),
      swRange: $("swRange"),
      serverSel: $("serverSel"),
      exportBtn: $("exportBtn")
    };

    const SPEEDTEST_TOKEN = window.NetNinjaApi?.token || "";
    const resolveApiUrl = window.NetNinjaApi?.resolveApiUrl || ((url) => url);
    function authHeaders(extra = {}){
      return SPEEDTEST_TOKEN ? { ...extra, Authorization: `Bearer ${SPEEDTEST_TOKEN}` } : { ...extra };
    }
    async function jsonFetch(url, options = {}){
      const res = await fetch(resolveApiUrl(url), {
        cache: "no-store",
        ...options,
        headers: authHeaders(options.headers || {})
      });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return res.json();
    }

    // Canvas setup
    const gCanvas = $("gaugeCanvas");
    const gCtx = gCanvas.getContext("2d");

    const hCanvas = $("histCanvas");
    const hCtx = hCanvas.getContext("2d");

    function fitCanvasToCSS(canvas){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width * dpr));
      const h = Math.max(1, Math.floor(rect.height * dpr));
      if (canvas.width !== w || canvas.height !== h){
        canvas.width = w; canvas.height = h;
      }
      return {w,h,dpr};
    }

    // Color helpers
    function rgba(r,g,b,a){ return `rgba(${r},${g},${b},${a})`; }
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
    function lerp(a,b,t){ return a + (b-a)*t; }
    function now(){ return performance.now(); }

    // Theme colors (kept in JS so we can do gradients reliably)
    const C = {
      // No green or purple. You’re welcome.
      cyan:   [0, 235, 255],
      blue:   [0, 160, 255],
      yellow: [255, 214, 0],
      amber:  [255, 174, 0],
      red:    [255, 47, 77],
      white:  [230, 251, 255],
      dim:    [170, 190, 198],
      bg:     [0, 0, 0]
    };

    // Gauge state
    const state = {
      running: false,
      aborted: false,
      useReal: true,
      precisionRange: false,

      phase: "idle", // idle, ping, download, upload, done
      phaseProgress: 0,

      speed: 0,   // current animated speed value
      target: 0,  // needle target
      unit: "Mbps",

      ping: null,
      jitter: null,
      dl: null,
      ul: null,

      loss: 0,
      bb: "low",
      threat: "LOW",

      server: "neo-1",

      history: [] // {ts, ping, jitter, dl, ul}
    };

    const servers = {
      "neo-1": { name: "NEO-1", hint: "Downtown Relay", baseDl: 520, baseUl: 95, ping: 9 },
      "arc-7": { name: "ARC-7", hint: "Subnet Spire", baseDl: 740, baseUl: 120, ping: 12 },
      "hex-3": { name: "HEX-3", hint: "Industrial Backbone", baseDl: 310, baseUl: 52, ping: 18 },
      "luna-9": { name: "LUNA-9", hint: "Edge Satellite", baseDl: 160, baseUl: 28, ping: 38 }
    };

    // Endpoints for REAL mode (same-origin!)
    const endpoints = {
      servers: "/api/v1/speedtest/servers",
      config: "/api/v1/speedtest/config",
      start: "/api/v1/speedtest/start",
      abort: "/api/v1/speedtest/abort",
      reset: "/api/v1/speedtest/reset",
      live: "/api/v1/speedtest/live",
      result: "/api/v1/speedtest/result",
      ping: "/api/v1/speedtest/ping",
      download: "/api/v1/speedtest/download?bytes=",
      upload: "/api/v1/speedtest/upload"
    };

    // Random but stable-ish noise
    function nrand(){
      // Box-Muller
      let u = 1 - Math.random();
      let v = 1 - Math.random();
      return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
    }

    function fmt(x, digits=2){
      if (x === null || x === undefined || Number.isNaN(x)) return "--";
      return Number(x).toFixed(digits);
    }

    function setPhase(phase, label){
      state.phase = phase;
      ui.phaseLabel.textContent = label;
      ui.phaseTiny.textContent = label;
      ui.phaseBar.style.width = `${Math.round(state.phaseProgress*100)}%`;
    }

    function setProgress(t){
      state.phaseProgress = clamp(t, 0, 1);
      ui.phaseBar.style.width = `${Math.round(state.phaseProgress*100)}%`;
    }

    function updateHUD(){
      ui.speedVal.textContent = fmt(state.speed, 2);
      ui.speedUnit.textContent = state.unit;

      ui.pingVal.textContent = fmt(state.ping, 0);
      ui.jitterVal.textContent = fmt(state.jitter, 1);
      ui.dlVal.textContent = fmt(state.dl, 2);
      ui.ulVal.textContent = fmt(state.ul, 2);

      ui.lossVal.textContent = `${fmt(state.loss, 1)}%`;
      ui.bbVal.textContent = state.bb;

      ui.threatLabel.textContent = state.threat;

      // Some flavor tags based on metrics
      const rf = clamp(60 + (state.ping ? (30 - state.ping) : 0) + (state.jitter ? (12 - state.jitter) : 0) + nrand()*2, 5, 95);
      ui.sigFill.style.width = `${rf}%`;

      const cong = (state.dl && state.ul) ? ((state.ping ?? 0) + (state.jitter ?? 0)) : null;
      let congLabel = "Unknown";
      if (cong !== null){
        if (cong < 18) congLabel = "Minimal";
        else if (cong < 32) congLabel = "Moderate";
        else congLabel = "High";
      }
      ui.congTxt.textContent = congLabel;

      ui.rfTxt.textContent = (rf > 78) ? "Nominal" : (rf > 55) ? "Noisy" : "Interference";
      ui.netState.textContent = (rf > 68) ? "LINK: STABLE • RF: NOMINAL" : "LINK: DEGRADED • RF: NOISY";

      // Threat heuristic (non-scientific, like most dashboards)
      let threat = "LOW";
      if ((state.loss > 1.5) || (state.jitter && state.jitter > 18)) threat = "MED";
      if ((state.loss > 3.5) || (state.ping && state.ping > 60)) threat = "HIGH";
      state.threat = threat;
      ui.threatLabel.textContent = threat;

      ui.histCount.textContent = String(state.history.length);
    
      applyMetricStyles();
    }

    function setLevel(el, level){
      if (!el) return;
      el.classList.remove("level-good","level-warn","level-bad");
      el.classList.add("level-" + level);
    }

    function applyMetricStyles(){
      // Ping
      if (state.ping != null){
        const p = state.ping;
        setLevel(ui.pingBox, (p < 20) ? "good" : (p < 50) ? "warn" : "bad");
      }

      // Jitter
      if (state.jitter != null){
        const j = state.jitter;
        setLevel(ui.jitterBox, (j < 5) ? "good" : (j < 15) ? "warn" : "bad");
      }

      // Download (higher is better)
      if (state.dl != null){
        const d = state.dl;
        // Aggressive thresholds: treat < 50 as "bad", < 200 as "warn"
        setLevel(ui.dlBox, (d >= 200) ? "good" : (d >= 50) ? "warn" : "bad");
      }

      // Upload (moderate thresholds)
      if (state.ul != null){
        const u = state.ul;
        setLevel(ui.ulBox, (u >= 50) ? "good" : (u >= 10) ? "warn" : "bad");
      }

      // Loss + bufferbloat inline badges
      setLevel(ui.lossVal, (state.loss <= 0.3) ? "good" : (state.loss <= 1.0) ? "warn" : "bad");

      const bb = (state.bb || "").toLowerCase();
      if (bb.includes("low")) setLevel(ui.bbVal, "good");
      else if (bb.includes("med") || bb.includes("mod")) setLevel(ui.bbVal, "warn");
      else if (bb.includes("high")) setLevel(ui.bbVal, "bad");
    }


    /* =========================
       Gauge rendering
       ========================= */
    function drawGauge(){
      const {w,h} = fitCanvasToCSS(gCanvas);
      gCtx.clearRect(0,0,w,h);

      // Geometry
      const cx = w * 0.50;
      const cy = h * 0.76;
      const r  = Math.min(w,h) * 0.48;

      const start = Math.PI * 1.05;
      const end   = Math.PI * 1.95;

      const maxMbps = state.precisionRange ? 200 : 1000;
      const value = clamp(state.speed, 0, maxMbps);
      const t = value / maxMbps;

      // Back glow
      const glow = gCtx.createRadialGradient(cx, cy, r*0.1, cx, cy, r*1.2);
      glow.addColorStop(0, rgba(...C.cyan, .10));
      glow.addColorStop(0.55, rgba(...C.amber, .06));
      glow.addColorStop(1, rgba(0,0,0,0));
      gCtx.fillStyle = glow;
      gCtx.beginPath();
      gCtx.arc(cx, cy, r*1.18, 0, Math.PI*2);
      gCtx.fill();

      // Grid arcs
      gCtx.lineWidth = r * 0.06;
      gCtx.lineCap = "round";
      gCtx.strokeStyle = rgba(255,255,255,.06);
      gCtx.beginPath();
      gCtx.arc(cx, cy, r, start, end);
      gCtx.stroke();

      // Neon arc gradient
      const grad = gCtx.createLinearGradient(cx - r, cy, cx + r, cy);
      grad.addColorStop(0, rgba(...C.cyan, .75));
      grad.addColorStop(0.5, rgba(...C.amber, .70));
      grad.addColorStop(1, rgba(...C.amber, .55));

      
      // Segmented ring (aggressive, instrument-style)
      const segs = 44;
      const segGap = 0.012; // radians gap between segments
      const segSpan = (end - start) / segs;
      for (let s=0; s<segs; s++){
        const s0 = start + s*segSpan + segGap;
        const s1 = start + (s+1)*segSpan - segGap;
        const st = (s+0.5)/segs;

        // Color zones: cyan -> yellow/amber -> red
        let col = C.cyan;
        if (st > 0.72 && st <= 0.88) col = C.amber;
        else if (st > 0.88) col = C.red;

        const filled = (st <= t);

        gCtx.strokeStyle = filled ? rgba(...col, 0.78) : rgba(...col, 0.16);
        gCtx.lineWidth = r * 0.050;
        gCtx.lineCap = "round";
        gCtx.beginPath();
        gCtx.arc(cx, cy, r*0.86, s0, s1);
        gCtx.stroke();
      }

// Progress arc
      gCtx.strokeStyle = grad;
      gCtx.shadowColor = rgba(...C.cyan, .35);
      gCtx.shadowBlur = 18;
      gCtx.beginPath();
      gCtx.arc(cx, cy, r, start, lerp(start, end, t));
      gCtx.stroke();
      gCtx.shadowBlur = 0;

      // Tick marks + labels
      const tickCount = state.precisionRange ? 10 : 10;
      const majorEvery = 1;
      for (let i=0; i<=tickCount; i++){
        const tt = i / tickCount;
        const a = lerp(start, end, tt);
        const inner = r * 0.88;
        const outer = r * 1.03;
        const x1 = cx + Math.cos(a)*inner;
        const y1 = cy + Math.sin(a)*inner;
        const x2 = cx + Math.cos(a)*outer;
        const y2 = cy + Math.sin(a)*outer;

        gCtx.lineWidth = (i % majorEvery === 0) ? 3 : 2;
        gCtx.strokeStyle = rgba(230,251,255, (i % majorEvery === 0) ? .22 : .12);
        gCtx.beginPath();
        gCtx.moveTo(x1,y1);
        gCtx.lineTo(x2,y2);
        gCtx.stroke();

        // Labels
        if (i % majorEvery === 0){
          const labelVal = Math.round(tt * maxMbps);
          const lx = cx + Math.cos(a) * (r*1.18);
          const ly = cy + Math.sin(a) * (r*1.18);

          gCtx.font = `${Math.max(11, Math.floor(r*0.085))}px ${FONT_MONO}`;
          gCtx.fillStyle = rgba(...C.white, .52);
          gCtx.textAlign = "center";
          gCtx.textBaseline = "middle";
          gCtx.fillText(String(labelVal), lx, ly);
        }
      }

      // Needle
      const needleA = lerp(start, end, t);
      const nx = cx + Math.cos(needleA) * (r*0.90);
      const ny = cy + Math.sin(needleA) * (r*0.90);

      // Aggressive needle: tapered blade + counterweight
      const bladeW = r * 0.030;
      const backLen = r * 0.18;

      const px = Math.cos(needleA + Math.PI/2) * bladeW;
      const py = Math.sin(needleA + Math.PI/2) * bladeW;

      const bx = cx - Math.cos(needleA) * backLen;
      const by = cy - Math.sin(needleA) * backLen;

      // Shadow
      gCtx.save();
      gCtx.translate(1, 2);
      gCtx.fillStyle = rgba(0,0,0,0.55);
      gCtx.beginPath();
      gCtx.moveTo(bx + px, by + py);
      gCtx.lineTo(cx + px, cy + py);
      gCtx.lineTo(nx, ny);
      gCtx.lineTo(cx - px, cy - py);
      gCtx.lineTo(bx - px, by - py);
      gCtx.closePath();
      gCtx.fill();
      gCtx.restore();

      // Blade
      const blade = gCtx.createLinearGradient(bx, by, nx, ny);
      blade.addColorStop(0, rgba(...C.white, .20));
      blade.addColorStop(0.25, rgba(...C.blue, .55));
      blade.addColorStop(0.65, rgba(...C.cyan, .80));
      blade.addColorStop(1, rgba(...C.amber, .90));

      gCtx.fillStyle = blade;
      gCtx.strokeStyle = rgba(...C.white, .12);
      gCtx.lineWidth = 2;
      gCtx.beginPath();
      gCtx.moveTo(bx + px, by + py);
      gCtx.lineTo(cx + px, cy + py);
      gCtx.lineTo(nx, ny);
      gCtx.lineTo(cx - px, cy - py);
      gCtx.lineTo(bx - px, by - py);
      gCtx.closePath();
      gCtx.fill();
      gCtx.stroke();

      // Counterweight ring
      gCtx.strokeStyle = rgba(...C.white, .12);
      gCtx.lineWidth = r * 0.020;
      gCtx.beginPath();
      gCtx.arc(cx, cy, r*0.20, 0, Math.PI*2);
      gCtx.stroke();


      // Needle tip glow
      const tip = gCtx.createRadialGradient(nx, ny, 0, nx, ny, r*0.12);
      tip.addColorStop(0, rgba(...C.amber, .82));
      tip.addColorStop(0.45, rgba(...C.blue, .40));
      tip.addColorStop(1, rgba(0,0,0,0));
      gCtx.fillStyle = tip;
      gCtx.beginPath();
      gCtx.arc(nx, ny, r*0.10, 0, Math.PI*2);
      gCtx.fill();

      // Hub
      const hub = gCtx.createRadialGradient(cx, cy, 0, cx, cy, r*0.18);
      hub.addColorStop(0, rgba(255,255,255,.30));
      hub.addColorStop(0.35, rgba(...C.cyan, .30));
      hub.addColorStop(1, rgba(0,0,0,0));
      gCtx.fillStyle = hub;
      gCtx.beginPath();
      gCtx.arc(cx, cy, r*0.14, 0, Math.PI*2);
      gCtx.fill();

      // Caption
      gCtx.font = `${Math.max(12, Math.floor(r*0.10))}px ${FONT_HUD}`;
      gCtx.fillStyle = rgba(...C.white, .72);
      gCtx.textAlign = "center";
      gCtx.textBaseline = "middle";
      gCtx.fillText("bits per second", cx, cy - r*0.38);

      // Minor HUD overlay text
      gCtx.font = `${Math.max(11, Math.floor(r*0.085))}px ${FONT_MONO}`;
      gCtx.fillStyle = rgba(...C.white, .42);
      gCtx.textAlign = "left";
      gCtx.fillText(state.useReal ? "MODE: REAL" : "MODE: SIM", w*0.06, h*0.10);
      gCtx.textAlign = "right";
      gCtx.fillText(`MAX: ${maxMbps} Mbps`, w*0.94, h*0.10);

      // Micro glyphs (cyberpunk garnish)
      gCtx.strokeStyle = rgba(...C.cyan, .10);
      gCtx.lineWidth = 2;
      for (let k=0;k<6;k++){
        const xx = w*(0.12 + k*0.14);
        const yy = h*(0.92);
        gCtx.beginPath();
        gCtx.moveTo(xx, yy);
        gCtx.lineTo(xx + w*0.06, yy);
        gCtx.stroke();
      }
    }

    /* =========================
       History chart
       ========================= */
    function drawHistory(){
      const {w,h} = fitCanvasToCSS(hCanvas);
      hCtx.clearRect(0,0,w,h);

      const pad = Math.max(18, Math.floor(w*0.04));
      const x0 = pad, y0 = pad, x1 = w - pad, y1 = h - pad;
      const cw = x1 - x0, ch = y1 - y0;

      // Frame
      hCtx.strokeStyle = rgba(...C.cyan, .14);
      hCtx.lineWidth = 2;
      hCtx.strokeRect(x0, y0, cw, ch);

      // Grid
      hCtx.strokeStyle = rgba(255,255,255,.06);
      hCtx.lineWidth = 1;
      const rows = 5, cols = 10;
      for (let i=1;i<rows;i++){
        const y = y0 + (ch*i/rows);
        hCtx.beginPath(); hCtx.moveTo(x0,y); hCtx.lineTo(x1,y); hCtx.stroke();
      }
      for (let i=1;i<cols;i++){
        const x = x0 + (cw*i/cols);
        hCtx.beginPath(); hCtx.moveTo(x,y0); hCtx.lineTo(x,y1); hCtx.stroke();
      }

      // No data
      if (state.history.length === 0){
        hCtx.font = `600 ${Math.max(12, Math.floor(w*0.03))}px ${FONT_MONO}`;
        hCtx.fillStyle = rgba(...C.white, .45);
        hCtx.textAlign = "center";
        hCtx.textBaseline = "middle";
        hCtx.fillText("No samples yet. Run a test to leave a trail.", w/2, h/2);
        return;
      }

      const data = state.history.slice(-20);
      const maxDl = Math.max(...data.map(d=>d.dl || 0), 1);
      const maxUl = Math.max(...data.map(d=>d.ul || 0), 1);
      const maxY = Math.max(maxDl, maxUl) * 1.15;

      function plotLine(vals, colorA, colorB){
        const grad = hCtx.createLinearGradient(x0,y0,x1,y1);
        grad.addColorStop(0, rgba(...colorA, .75));
        grad.addColorStop(1, rgba(...colorB, .65));
        hCtx.strokeStyle = grad;
        hCtx.lineWidth = 3;
        hCtx.lineJoin = "round";
        hCtx.beginPath();
        vals.forEach((v,i)=>{
          const t = (data.length === 1) ? 0 : (i/(data.length-1));
          const x = x0 + t*cw;
          const y = y1 - (v/maxY)*ch;
          if (i===0) hCtx.moveTo(x,y);
          else hCtx.lineTo(x,y);
        });
        hCtx.stroke();
      }

      plotLine(data.map(d=>d.dl||0), C.cyan, C.amber);
      plotLine(data.map(d=>d.ul||0), C.amber, C.cyan);

      // Legend
      hCtx.font = `600 ${Math.max(10, Math.floor(w*0.022))}px ${FONT_MONO}`;
      hCtx.textAlign = "left";
      hCtx.textBaseline = "top";
      hCtx.fillStyle = rgba(...C.white, .62);
      hCtx.fillText("DL", x0 + 10, y0 + 10);
      hCtx.fillStyle = rgba(...C.cyan, .65);
      hCtx.fillRect(x0 + 40, y0 + 14, 18, 6);

      hCtx.fillStyle = rgba(...C.white, .62);
      hCtx.fillText("UL", x0 + 70, y0 + 10);
      hCtx.fillStyle = rgba(...C.amber, .65);
      hCtx.fillRect(x0 + 100, y0 + 14, 18, 6);

      // Scale label
      hCtx.textAlign = "right";
      hCtx.fillStyle = rgba(...C.white, .45);
      hCtx.fillText(`max ~ ${maxY.toFixed(0)} Mbps`, x1 - 10, y0 + 10);
    }

    /* =========================
       Speedtest engine
       ========================= */

    // Smooth needle
    function animateNeedle(){
      // critically damped-ish ease
      const diff = state.target - state.speed;
      state.speed += diff * 0.14;
      if (Math.abs(diff) < 0.02) state.speed = state.target;

      updateHUD();
      drawGauge();
      drawHistory();

      requestAnimationFrame(animateNeedle);
    }

    function setServer(id){
      state.server = id;
      ui.serverName.textContent = servers[id]?.name || id.toUpperCase();
      jsonFetch(endpoints.config, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ serverId: id })
      }).catch(() => {});
    }

    async function syncRemoteConfig(){
      try {
        const cfg = await jsonFetch(endpoints.config);
        if (cfg && typeof cfg === "object") {
          if (typeof cfg.serverId === "string" && cfg.serverId) {
            state.server = cfg.serverId;
          }
          if (typeof cfg.realMode === "boolean") {
            state.useReal = cfg.realMode;
          }
          if (typeof cfg.precisionRange === "boolean") {
            state.precisionRange = cfg.precisionRange;
          }
        }
      } catch (_) {}
    }

    async function loadServers(){
      try {
        const list = await jsonFetch(endpoints.servers);
        if (!Array.isArray(list) || !ui.serverSel) return;
        const current = state.server;
        ui.serverSel.innerHTML = list.map((srv) => {
          const id = String(srv.id || "").trim();
          const name = String(srv.name || id.toUpperCase());
          const location = String(srv.location || "Local");
          return `<option value="${id}">${name} • ${location}</option>`;
        }).join("");
        if (Array.from(ui.serverSel.options).some((opt) => opt.value === current)) {
          ui.serverSel.value = current;
        } else if (ui.serverSel.options.length > 0) {
          ui.serverSel.value = ui.serverSel.options[0].value;
          state.server = ui.serverSel.value;
        }
      } catch (_) {}
    }

    // SIMULATION phases (works anywhere, looks real enough to fool humans)
    async function runSim(){
      const s = servers[state.server] || servers["neo-1"];
      ui.protoTxt.textContent = "HTTP/2 (sim)";
      ui.modeLabel.textContent = "SIM";
      ui.modeLabel.style.textShadow = "0 0 14px rgba(0,235,255,.22)";
      state.useReal = false;
      ui.swReal.classList.remove("on");
      ui.swReal.setAttribute("aria-checked", "false");

      // Phase: ping
      setPhase("ping", "Measuring latency");
      state.phaseProgress = 0;
      const pings = [];
      const basePing = s.ping + Math.max(0, nrand()*2);
      for (let i=0;i<10;i++){
        if (state.aborted) throw new Error("aborted");
        const jitter = Math.abs(nrand()*2.4);
        const val = basePing + jitter;
        pings.push(val);
        state.ping = val;
        state.jitter = i<2 ? null : stddev(pings);
        setProgress((i+1)/10);
        state.target = 0 + (i/10)*20; // tiny needle twitch
        await sleep(65 + Math.random()*60);
      }
      state.ping = avg(pings);
      state.jitter = stddev(pings);
      setProgress(1);

      // Phase: download
      setPhase("download", "Downloading packet swarm");
      const dlTarget = s.baseDl * (0.88 + Math.random()*0.30);
      const dlCurve = makeCurve(dlTarget, 2200, 0.14);
      let dlNow = 0;

      for (let t=0; t<=1.0; t += 0.016){
        if (state.aborted) throw new Error("aborted");
        const noise = nrand()* (dlTarget*0.015);
        dlNow = clamp(dlCurve(t) + noise, 0, dlTarget*1.05);
        state.target = dlNow;
        state.dl = dlNow;
        setProgress(t);
        // plausible loss/bufferbloat updates
        state.loss = clamp(Math.abs(nrand()) * 0.7 + (state.jitter/50), 0, 6.5);
        state.bb = (state.jitter < 6) ? "low" : (state.jitter < 14) ? "med" : "high";
        await sleep(16);
      }
      state.dl = dlTarget;
      state.target = dlTarget;
      setProgress(1);

      // Phase: upload
      setPhase("upload", "Uploading telemetry burst");
      const ulTarget = s.baseUl * (0.86 + Math.random()*0.34);
      const ulCurve = makeCurve(ulTarget, 1900, 0.16);
      let ulNow = 0;

      for (let t=0; t<=1.0; t += 0.016){
        if (state.aborted) throw new Error("aborted");
        const noise = nrand()* (ulTarget*0.02);
        ulNow = clamp(ulCurve(t) + noise, 0, ulTarget*1.08);
        state.target = ulNow;
        state.ul = ulNow;
        setProgress(t);
        await sleep(16);
      }
      state.ul = ulTarget;
      state.target = ulTarget;
      setProgress(1);

      // Done
      setPhase("done", "Complete");
      state.target = 0; // needle relax back down slowly
      setProgress(1);

      pushHistory();
      postAnalyze();
    }

    // REAL measurement (best-effort, same-origin only)
    async function runReal(){
      ui.modeLabel.textContent = "REAL";
      ui.modeLabel.style.textShadow = "0 0 18px rgba(0,246,255,.35)";
      state.useReal = true;
      ui.protoTxt.textContent = "Backend stream (real)";
      await jsonFetch(endpoints.start, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          serverId: state.server,
          realMode: true,
          precisionRange: state.precisionRange
        })
      });
      // Phase: ping
      setPhase("ping", "Measuring latency (real)");
      const pings = [];
      for (let i=0;i<8;i++){
        if (state.aborted) throw new Error("aborted");
        const t0 = now();
        // cache-bust
        const url = `${endpoints.ping}?t=${Math.random().toString(16).slice(2)}`;
        const res = await fetch(resolveApiUrl(url), { cache: "no-store", headers: authHeaders() });
        if (!res.ok) throw new Error("ping failed");
        await res.arrayBuffer().catch(()=>{});
        const dt = now() - t0;
        pings.push(dt);
        state.ping = dt;
        state.jitter = i<2 ? null : stddev(pings);
        setProgress((i+1)/8);
        await sleep(50);
      }
      state.ping = avg(pings);
      state.jitter = stddev(pings);
      setProgress(1);

      // Phase: download (stream bytes)
      setPhase("download", "Download test (real)");
      state.target = 0;
      const dlMbps = await measureDownloadMbps(25_000_000); // 25MB
      state.dl = dlMbps;
      state.target = dlMbps;
      setProgress(1);

      // Phase: upload (POST body)
      setPhase("upload", "Upload test (real)");
      const ulMbps = await measureUploadMbps(12_000_000); // 12MB
      state.ul = ulMbps;
      state.target = ulMbps;
      setProgress(1);

      setPhase("done", "Complete");
      state.target = 0;
      setProgress(1);

      // loss/bb are not truly measured here; estimate lightly
      state.loss = clamp(Math.abs(nrand()) * 0.4 + (state.jitter/60), 0, 4.0);
      state.bb = (state.jitter < 6) ? "low" : (state.jitter < 14) ? "med" : "high";

      pushHistory();
      postAnalyze();
      await jsonFetch(endpoints.result, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          running: false,
          phase: "COMPLETE",
          progress: 100,
          serverId: state.server,
          pingMs: state.ping,
          jitterMs: state.jitter,
          downloadMbps: state.dl,
          uploadMbps: state.ul,
          lossPct: state.loss,
          bufferbloat: state.bb
        })
      }).catch(() => {});
    }

    function postAnalyze(){
      // Route tag: based on ping/jitter/loss
      const p = state.ping ?? 999;
      const j = state.jitter ?? 999;
      const l = state.loss ?? 0;

      if (p < 18 && j < 6 && l < 1.0) ui.routeTag.textContent = "Clean";
      else if (p < 35 && j < 12 && l < 2.0) ui.routeTag.textContent = "Stable";
      else ui.routeTag.textContent = "Chaotic";

      // Congestion tag color
      const congEl = $("congTag");
      congEl.classList.remove("good","warn","bad");
      let cls = "warn";
      if (p < 22 && j < 8) cls = "good";
      if (p > 55 || j > 18 || l > 3.0) cls = "bad";
      congEl.classList.add(cls);

      // RF tag color
      const rfEl = $("rfTag");
      rfEl.classList.remove("good","warn","bad");
      if (p < 22) rfEl.classList.add("good");
      else if (p < 45) rfEl.classList.add("warn");
      else rfEl.classList.add("bad");
    }

    function pushHistory(){
      state.history.push({
        ts: Date.now(),
        ping: state.ping,
        jitter: state.jitter,
        dl: state.dl,
        ul: state.ul
      });
      // cap
      if (state.history.length > 60) state.history.shift();
    }

    function avg(arr){ return arr.reduce((a,b)=>a+b,0)/Math.max(1,arr.length); }
    function stddev(arr){
      if (arr.length < 2) return 0;
      const m = avg(arr);
      const v = arr.reduce((s,x)=>s + (x-m)*(x-m), 0) / (arr.length-1);
      return Math.sqrt(v);
    }
    function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

    function makeCurve(target, ms, sharpness){
      // Ease-out curve with a little "ramp" that feels like throughput stabilization.
      const total = ms;
      return (t)=>{
        const x = clamp(t,0,1);
        const a = 1 - Math.pow(1-x, 3.1);
        const wobble = Math.sin(x*10) * (1-x) * (target*sharpness);
        return target*a + wobble;
      };
    }

    async function measureDownloadMbps(bytes){
      // Streams a download and updates the needle live.
      const url = `${endpoints.download}${encodeURIComponent(bytes)}&t=${Math.random().toString(16).slice(2)}`;
      const t0 = now();
      const res = await fetch(resolveApiUrl(url), { cache: "no-store", headers: authHeaders() });
      if (!res.ok || !res.body) throw new Error("download failed");

      const reader = res.body.getReader();
      let received = 0;
      let lastUI = t0;

      while (true){
        if (state.aborted) throw new Error("aborted");
        const {done, value} = await reader.read();
        if (done) break;
        received += value.byteLength;

        const t1 = now();
        const dt = (t1 - t0) / 1000;
        if (dt > 0){
          const mbps = (received * 8) / (dt * 1_000_000);
          state.dl = mbps;
          state.target = mbps;
          const prog = clamp(received / bytes, 0, 1);
          setProgress(prog);
        }
        // throttle UI a bit
        if (t1 - lastUI > 60){
          lastUI = t1;
          await sleep(0);
        }
      }

      const tEnd = now();
      const secs = (tEnd - t0) / 1000;
      const mbps = (received * 8) / (secs * 1_000_000);
      return mbps;
    }

    async function measureUploadMbps(bytes){
      // Posts a blob and times it.
      // Note: Real upload measurement is notoriously noisy.
      const blob = new Blob([new Uint8Array(bytes)], { type: "application/octet-stream" });
      const t0 = now();
      setProgress(0);
      state.target = 0;

      // Fire and track coarse progress by time slicing (no streaming upload progress in fetch without hacks)
      const tick = (async ()=>{
        let k = 0;
        while (!state.aborted){
          const dt = (now() - t0) / 1000;
          const est = clamp(dt / 2.2, 0, 0.95); // faux progress while upload happens
          setProgress(est);
          state.target = est * 120; // small needle movement
          k++;
          await sleep(70);
          if (k > 80) break;
        }
      })();

      const res = await fetch(resolveApiUrl(endpoints.upload), {
        method: "POST",
        cache: "no-store",
        headers: authHeaders({ "Content-Type": "application/octet-stream" }),
        body: blob
      });

      if (!res.ok) throw new Error("upload failed");
      await res.arrayBuffer().catch(()=>{});

      const tEnd = now();
      const secs = (tEnd - t0) / 1000;
      const mbps = (bytes * 8) / (secs * 1_000_000);
      setProgress(1);
      return mbps;
    }

    async function runTest(){
      if (state.running) return;
      state.running = true;
      state.aborted = false;

      ui.btnStart.disabled = true;
      ui.btnAbort.disabled = false;

      // Reset displayed values except history
      state.speed = 0;
      state.target = 0;
      state.ping = null;
      state.jitter = null;
      state.dl = null;
      state.ul = null;
      state.loss = 0;
      state.bb = "low";
      state.phaseProgress = 0;
      setProgress(0);
      setPhase("idle", "Initializing");

      // Small startup animation
      for (let i=0;i<12;i++){
        if (state.aborted) break;
        state.target = (i/12) * (state.precisionRange ? 40 : 80);
        setProgress(i/12);
        await sleep(25);
      }

      try{
        if (state.useReal) {
          await runReal();
        } else {
          await runSim();
        }
      } catch (e){
        setPhase("idle", state.aborted ? "Aborted" : "Error");
        await jsonFetch(endpoints.result, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            running: false,
            phase: state.aborted ? "ABORTED" : "ERROR",
            progress: state.aborted ? state.phaseProgress * 100 : 0,
            serverId: state.server,
            error: e?.message ? String(e.message) : "speedtest failed"
          })
        }).catch(() => {});
      } finally{
        state.running = false;
        ui.btnStart.disabled = false;
        ui.btnAbort.disabled = true;
        setProgress(0);
      }
    }

    function abortTest(){
      if (!state.running) return;
      state.aborted = true;
      setPhase("idle", "Abort signal sent");
      state.target = 0;
      ui.btnAbort.disabled = true;
      jsonFetch(endpoints.abort, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: "{}"
      }).catch(() => {});
    }

    function resetUI(){
      if (state.running) return;
      state.speed = 0;
      state.target = 0;
      state.ping = null;
      state.jitter = null;
      state.dl = null;
      state.ul = null;
      state.loss = 0;
      state.bb = "low";
      state.phaseProgress = 0;
      setPhase("idle", "Awaiting command");
      setProgress(0);
      updateHUD();
      jsonFetch(endpoints.reset, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: "{}"
      }).catch(() => {});
    }

    function toggleSwitch(el, on){
      el.classList.toggle("on", on);
      el.setAttribute("aria-checked", on ? "true" : "false");
    }

    // Wire UI
    ui.btnStart.addEventListener("click", runTest);
    ui.btnAbort.addEventListener("click", abortTest);
    ui.btnReset.addEventListener("click", resetUI);

    ui.serverSel.addEventListener("change", (e)=>{
      const id = e.target.value;
      setServer(id);
    });

    function clickSwitch(sw, handler){
      sw.addEventListener("click", handler);
      sw.addEventListener("keydown", (e)=>{
        if (e.key === "Enter" || e.key === " "){
          e.preventDefault();
          handler();
        }
      });
    }

    clickSwitch(ui.swReal, ()=>{
      if (state.running) return;
      state.useReal = !state.useReal;
      toggleSwitch(ui.swReal, state.useReal);
      if (state.useReal) {
        ui.modeLabel.textContent = "REAL";
        ui.modeLabel.style.textShadow = "0 0 18px rgba(0,246,255,.35)";
        ui.protoTxt.textContent = "Backend stream (real)";
      } else {
        ui.modeLabel.textContent = "SIM";
        ui.modeLabel.style.textShadow = "0 0 14px rgba(0,235,255,.22)";
        ui.protoTxt.textContent = "HTTP/2 (sim)";
      }
      jsonFetch(endpoints.config, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ realMode: state.useReal })
      }).catch(() => {});
    });

    clickSwitch(ui.swRange, ()=>{
      if (state.running) return;
      state.precisionRange = !state.precisionRange;
      toggleSwitch(ui.swRange, state.precisionRange);
      jsonFetch(endpoints.config, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ precisionRange: state.precisionRange })
      }).catch(() => {});
    });

    ui.exportBtn.addEventListener("click", (e)=>{
      e.preventDefault();
      const last = state.history[state.history.length - 1];
      const payload = {
        server: state.server,
        ts: new Date(last?.ts || Date.now()).toISOString(),
        ping_ms: last?.ping ?? null,
        jitter_ms: last?.jitter ?? null,
        download_mbps: last?.dl ?? null,
        upload_mbps: last?.ul ?? null,
        mode: state.useReal ? "REAL (attempt)" : "SIM"
      };
      const txt = JSON.stringify(payload, null, 2);
      navigator.clipboard?.writeText(txt).catch(()=>{});
      ui.phaseLabel.textContent = "Exported (copied to clipboard)";
      setTimeout(()=>{ if (!state.running) ui.phaseLabel.textContent = "Awaiting command"; }, 1200);
    });

    // Init
    (async () => {
      await syncRemoteConfig();
      await loadServers();
      if (ui.serverSel.value) {
        state.server = ui.serverSel.value;
      }
      setServer(state.server || ui.serverSel.value || "neo-1");
      toggleSwitch(ui.swReal, state.useReal);
      toggleSwitch(ui.swRange, state.precisionRange);
      ui.modeLabel.textContent = state.useReal ? "REAL" : "SIM";
      ui.protoTxt.textContent = state.useReal ? "Backend stream (real)" : "HTTP/2 (sim)";
      updateHUD();
      animateNeedle();
    })();

    // Resize redraw
    window.addEventListener("resize", ()=>{
      drawGauge();
      drawHistory();
    });

    // Initial draw
    drawGauge();
    drawHistory();
  </script>
</body>
</html>
